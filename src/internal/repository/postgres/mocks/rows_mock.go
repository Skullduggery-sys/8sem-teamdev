// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/jackc/pgx/v4.Rows -o rows_mock.go -n RowsMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgproto3/v2"
)

// RowsMock implements mm_pgx.Rows
type RowsMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func()
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRowsMockClose

	funcCommandTag          func() (c1 pgconn.CommandTag)
	funcCommandTagOrigin    string
	inspectFuncCommandTag   func()
	afterCommandTagCounter  uint64
	beforeCommandTagCounter uint64
	CommandTagMock          mRowsMockCommandTag

	funcErr          func() (err error)
	funcErrOrigin    string
	inspectFuncErr   func()
	afterErrCounter  uint64
	beforeErrCounter uint64
	ErrMock          mRowsMockErr

	funcFieldDescriptions          func() (fa1 []pgproto3.FieldDescription)
	funcFieldDescriptionsOrigin    string
	inspectFuncFieldDescriptions   func()
	afterFieldDescriptionsCounter  uint64
	beforeFieldDescriptionsCounter uint64
	FieldDescriptionsMock          mRowsMockFieldDescriptions

	funcNext          func() (b1 bool)
	funcNextOrigin    string
	inspectFuncNext   func()
	afterNextCounter  uint64
	beforeNextCounter uint64
	NextMock          mRowsMockNext

	funcRawValues          func() (baa1 [][]byte)
	funcRawValuesOrigin    string
	inspectFuncRawValues   func()
	afterRawValuesCounter  uint64
	beforeRawValuesCounter uint64
	RawValuesMock          mRowsMockRawValues

	funcScan          func(dest ...interface{}) (err error)
	funcScanOrigin    string
	inspectFuncScan   func(dest ...interface{})
	afterScanCounter  uint64
	beforeScanCounter uint64
	ScanMock          mRowsMockScan

	funcValues          func() (pa1 []interface{}, err error)
	funcValuesOrigin    string
	inspectFuncValues   func()
	afterValuesCounter  uint64
	beforeValuesCounter uint64
	ValuesMock          mRowsMockValues
}

// NewRowsMock returns a mock for mm_pgx.Rows
func NewRowsMock(t minimock.Tester) *RowsMock {
	m := &RowsMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mRowsMockClose{mock: m}

	m.CommandTagMock = mRowsMockCommandTag{mock: m}

	m.ErrMock = mRowsMockErr{mock: m}

	m.FieldDescriptionsMock = mRowsMockFieldDescriptions{mock: m}

	m.NextMock = mRowsMockNext{mock: m}

	m.RawValuesMock = mRowsMockRawValues{mock: m}

	m.ScanMock = mRowsMockScan{mock: m}
	m.ScanMock.callArgs = []*RowsMockScanParams{}

	m.ValuesMock = mRowsMockValues{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRowsMockClose struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockCloseExpectation
	expectations       []*RowsMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockCloseExpectation specifies expectation struct of the Rows.Close
type RowsMockCloseExpectation struct {
	mock *RowsMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mRowsMockClose) Optional() *mRowsMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Rows.Close
func (mmClose *mRowsMockClose) Expect() *mRowsMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RowsMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RowsMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Rows.Close
func (mmClose *mRowsMockClose) Inspect(f func()) *mRowsMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RowsMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Rows.Close
func (mmClose *mRowsMockClose) Return() *RowsMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RowsMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RowsMockCloseExpectation{mock: mmClose.mock}
	}

	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Rows.Close method
func (mmClose *mRowsMockClose) Set(f func()) *RowsMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Rows.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Rows.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Rows.Close should be invoked
func (mmClose *mRowsMockClose) Times(n uint64) *mRowsMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of RowsMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mRowsMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_pgx.Rows
func (mmClose *RowsMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to RowsMock.Close.")

}

// CloseAfterCounter returns a count of finished RowsMock.Close invocations
func (mmClose *RowsMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RowsMock.Close invocations
func (mmClose *RowsMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *RowsMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mRowsMockCommandTag struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockCommandTagExpectation
	expectations       []*RowsMockCommandTagExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockCommandTagExpectation specifies expectation struct of the Rows.CommandTag
type RowsMockCommandTagExpectation struct {
	mock *RowsMock

	results      *RowsMockCommandTagResults
	returnOrigin string
	Counter      uint64
}

// RowsMockCommandTagResults contains results of the Rows.CommandTag
type RowsMockCommandTagResults struct {
	c1 pgconn.CommandTag
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommandTag *mRowsMockCommandTag) Optional() *mRowsMockCommandTag {
	mmCommandTag.optional = true
	return mmCommandTag
}

// Expect sets up expected params for Rows.CommandTag
func (mmCommandTag *mRowsMockCommandTag) Expect() *mRowsMockCommandTag {
	if mmCommandTag.mock.funcCommandTag != nil {
		mmCommandTag.mock.t.Fatalf("RowsMock.CommandTag mock is already set by Set")
	}

	if mmCommandTag.defaultExpectation == nil {
		mmCommandTag.defaultExpectation = &RowsMockCommandTagExpectation{}
	}

	return mmCommandTag
}

// Inspect accepts an inspector function that has same arguments as the Rows.CommandTag
func (mmCommandTag *mRowsMockCommandTag) Inspect(f func()) *mRowsMockCommandTag {
	if mmCommandTag.mock.inspectFuncCommandTag != nil {
		mmCommandTag.mock.t.Fatalf("Inspect function is already set for RowsMock.CommandTag")
	}

	mmCommandTag.mock.inspectFuncCommandTag = f

	return mmCommandTag
}

// Return sets up results that will be returned by Rows.CommandTag
func (mmCommandTag *mRowsMockCommandTag) Return(c1 pgconn.CommandTag) *RowsMock {
	if mmCommandTag.mock.funcCommandTag != nil {
		mmCommandTag.mock.t.Fatalf("RowsMock.CommandTag mock is already set by Set")
	}

	if mmCommandTag.defaultExpectation == nil {
		mmCommandTag.defaultExpectation = &RowsMockCommandTagExpectation{mock: mmCommandTag.mock}
	}
	mmCommandTag.defaultExpectation.results = &RowsMockCommandTagResults{c1}
	mmCommandTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommandTag.mock
}

// Set uses given function f to mock the Rows.CommandTag method
func (mmCommandTag *mRowsMockCommandTag) Set(f func() (c1 pgconn.CommandTag)) *RowsMock {
	if mmCommandTag.defaultExpectation != nil {
		mmCommandTag.mock.t.Fatalf("Default expectation is already set for the Rows.CommandTag method")
	}

	if len(mmCommandTag.expectations) > 0 {
		mmCommandTag.mock.t.Fatalf("Some expectations are already set for the Rows.CommandTag method")
	}

	mmCommandTag.mock.funcCommandTag = f
	mmCommandTag.mock.funcCommandTagOrigin = minimock.CallerInfo(1)
	return mmCommandTag.mock
}

// Times sets number of times Rows.CommandTag should be invoked
func (mmCommandTag *mRowsMockCommandTag) Times(n uint64) *mRowsMockCommandTag {
	if n == 0 {
		mmCommandTag.mock.t.Fatalf("Times of RowsMock.CommandTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommandTag.expectedInvocations, n)
	mmCommandTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommandTag
}

func (mmCommandTag *mRowsMockCommandTag) invocationsDone() bool {
	if len(mmCommandTag.expectations) == 0 && mmCommandTag.defaultExpectation == nil && mmCommandTag.mock.funcCommandTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommandTag.mock.afterCommandTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommandTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommandTag implements mm_pgx.Rows
func (mmCommandTag *RowsMock) CommandTag() (c1 pgconn.CommandTag) {
	mm_atomic.AddUint64(&mmCommandTag.beforeCommandTagCounter, 1)
	defer mm_atomic.AddUint64(&mmCommandTag.afterCommandTagCounter, 1)

	mmCommandTag.t.Helper()

	if mmCommandTag.inspectFuncCommandTag != nil {
		mmCommandTag.inspectFuncCommandTag()
	}

	if mmCommandTag.CommandTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommandTag.CommandTagMock.defaultExpectation.Counter, 1)

		mm_results := mmCommandTag.CommandTagMock.defaultExpectation.results
		if mm_results == nil {
			mmCommandTag.t.Fatal("No results are set for the RowsMock.CommandTag")
		}
		return (*mm_results).c1
	}
	if mmCommandTag.funcCommandTag != nil {
		return mmCommandTag.funcCommandTag()
	}
	mmCommandTag.t.Fatalf("Unexpected call to RowsMock.CommandTag.")
	return
}

// CommandTagAfterCounter returns a count of finished RowsMock.CommandTag invocations
func (mmCommandTag *RowsMock) CommandTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommandTag.afterCommandTagCounter)
}

// CommandTagBeforeCounter returns a count of RowsMock.CommandTag invocations
func (mmCommandTag *RowsMock) CommandTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommandTag.beforeCommandTagCounter)
}

// MinimockCommandTagDone returns true if the count of the CommandTag invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockCommandTagDone() bool {
	if m.CommandTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommandTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommandTagMock.invocationsDone()
}

// MinimockCommandTagInspect logs each unmet expectation
func (m *RowsMock) MinimockCommandTagInspect() {
	for _, e := range m.CommandTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.CommandTag")
		}
	}

	afterCommandTagCounter := mm_atomic.LoadUint64(&m.afterCommandTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommandTagMock.defaultExpectation != nil && afterCommandTagCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.CommandTag at\n%s", m.CommandTagMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommandTag != nil && afterCommandTagCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.CommandTag at\n%s", m.funcCommandTagOrigin)
	}

	if !m.CommandTagMock.invocationsDone() && afterCommandTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.CommandTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommandTagMock.expectedInvocations), m.CommandTagMock.expectedInvocationsOrigin, afterCommandTagCounter)
	}
}

type mRowsMockErr struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockErrExpectation
	expectations       []*RowsMockErrExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockErrExpectation specifies expectation struct of the Rows.Err
type RowsMockErrExpectation struct {
	mock *RowsMock

	results      *RowsMockErrResults
	returnOrigin string
	Counter      uint64
}

// RowsMockErrResults contains results of the Rows.Err
type RowsMockErrResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErr *mRowsMockErr) Optional() *mRowsMockErr {
	mmErr.optional = true
	return mmErr
}

// Expect sets up expected params for Rows.Err
func (mmErr *mRowsMockErr) Expect() *mRowsMockErr {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("RowsMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &RowsMockErrExpectation{}
	}

	return mmErr
}

// Inspect accepts an inspector function that has same arguments as the Rows.Err
func (mmErr *mRowsMockErr) Inspect(f func()) *mRowsMockErr {
	if mmErr.mock.inspectFuncErr != nil {
		mmErr.mock.t.Fatalf("Inspect function is already set for RowsMock.Err")
	}

	mmErr.mock.inspectFuncErr = f

	return mmErr
}

// Return sets up results that will be returned by Rows.Err
func (mmErr *mRowsMockErr) Return(err error) *RowsMock {
	if mmErr.mock.funcErr != nil {
		mmErr.mock.t.Fatalf("RowsMock.Err mock is already set by Set")
	}

	if mmErr.defaultExpectation == nil {
		mmErr.defaultExpectation = &RowsMockErrExpectation{mock: mmErr.mock}
	}
	mmErr.defaultExpectation.results = &RowsMockErrResults{err}
	mmErr.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmErr.mock
}

// Set uses given function f to mock the Rows.Err method
func (mmErr *mRowsMockErr) Set(f func() (err error)) *RowsMock {
	if mmErr.defaultExpectation != nil {
		mmErr.mock.t.Fatalf("Default expectation is already set for the Rows.Err method")
	}

	if len(mmErr.expectations) > 0 {
		mmErr.mock.t.Fatalf("Some expectations are already set for the Rows.Err method")
	}

	mmErr.mock.funcErr = f
	mmErr.mock.funcErrOrigin = minimock.CallerInfo(1)
	return mmErr.mock
}

// Times sets number of times Rows.Err should be invoked
func (mmErr *mRowsMockErr) Times(n uint64) *mRowsMockErr {
	if n == 0 {
		mmErr.mock.t.Fatalf("Times of RowsMock.Err mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErr.expectedInvocations, n)
	mmErr.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmErr
}

func (mmErr *mRowsMockErr) invocationsDone() bool {
	if len(mmErr.expectations) == 0 && mmErr.defaultExpectation == nil && mmErr.mock.funcErr == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErr.mock.afterErrCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErr.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Err implements mm_pgx.Rows
func (mmErr *RowsMock) Err() (err error) {
	mm_atomic.AddUint64(&mmErr.beforeErrCounter, 1)
	defer mm_atomic.AddUint64(&mmErr.afterErrCounter, 1)

	mmErr.t.Helper()

	if mmErr.inspectFuncErr != nil {
		mmErr.inspectFuncErr()
	}

	if mmErr.ErrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErr.ErrMock.defaultExpectation.Counter, 1)

		mm_results := mmErr.ErrMock.defaultExpectation.results
		if mm_results == nil {
			mmErr.t.Fatal("No results are set for the RowsMock.Err")
		}
		return (*mm_results).err
	}
	if mmErr.funcErr != nil {
		return mmErr.funcErr()
	}
	mmErr.t.Fatalf("Unexpected call to RowsMock.Err.")
	return
}

// ErrAfterCounter returns a count of finished RowsMock.Err invocations
func (mmErr *RowsMock) ErrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.afterErrCounter)
}

// ErrBeforeCounter returns a count of RowsMock.Err invocations
func (mmErr *RowsMock) ErrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErr.beforeErrCounter)
}

// MinimockErrDone returns true if the count of the Err invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockErrDone() bool {
	if m.ErrMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrMock.invocationsDone()
}

// MinimockErrInspect logs each unmet expectation
func (m *RowsMock) MinimockErrInspect() {
	for _, e := range m.ErrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.Err")
		}
	}

	afterErrCounter := mm_atomic.LoadUint64(&m.afterErrCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrMock.defaultExpectation != nil && afterErrCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Err at\n%s", m.ErrMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErr != nil && afterErrCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Err at\n%s", m.funcErrOrigin)
	}

	if !m.ErrMock.invocationsDone() && afterErrCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.Err at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrMock.expectedInvocations), m.ErrMock.expectedInvocationsOrigin, afterErrCounter)
	}
}

type mRowsMockFieldDescriptions struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockFieldDescriptionsExpectation
	expectations       []*RowsMockFieldDescriptionsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockFieldDescriptionsExpectation specifies expectation struct of the Rows.FieldDescriptions
type RowsMockFieldDescriptionsExpectation struct {
	mock *RowsMock

	results      *RowsMockFieldDescriptionsResults
	returnOrigin string
	Counter      uint64
}

// RowsMockFieldDescriptionsResults contains results of the Rows.FieldDescriptions
type RowsMockFieldDescriptionsResults struct {
	fa1 []pgproto3.FieldDescription
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFieldDescriptions *mRowsMockFieldDescriptions) Optional() *mRowsMockFieldDescriptions {
	mmFieldDescriptions.optional = true
	return mmFieldDescriptions
}

// Expect sets up expected params for Rows.FieldDescriptions
func (mmFieldDescriptions *mRowsMockFieldDescriptions) Expect() *mRowsMockFieldDescriptions {
	if mmFieldDescriptions.mock.funcFieldDescriptions != nil {
		mmFieldDescriptions.mock.t.Fatalf("RowsMock.FieldDescriptions mock is already set by Set")
	}

	if mmFieldDescriptions.defaultExpectation == nil {
		mmFieldDescriptions.defaultExpectation = &RowsMockFieldDescriptionsExpectation{}
	}

	return mmFieldDescriptions
}

// Inspect accepts an inspector function that has same arguments as the Rows.FieldDescriptions
func (mmFieldDescriptions *mRowsMockFieldDescriptions) Inspect(f func()) *mRowsMockFieldDescriptions {
	if mmFieldDescriptions.mock.inspectFuncFieldDescriptions != nil {
		mmFieldDescriptions.mock.t.Fatalf("Inspect function is already set for RowsMock.FieldDescriptions")
	}

	mmFieldDescriptions.mock.inspectFuncFieldDescriptions = f

	return mmFieldDescriptions
}

// Return sets up results that will be returned by Rows.FieldDescriptions
func (mmFieldDescriptions *mRowsMockFieldDescriptions) Return(fa1 []pgproto3.FieldDescription) *RowsMock {
	if mmFieldDescriptions.mock.funcFieldDescriptions != nil {
		mmFieldDescriptions.mock.t.Fatalf("RowsMock.FieldDescriptions mock is already set by Set")
	}

	if mmFieldDescriptions.defaultExpectation == nil {
		mmFieldDescriptions.defaultExpectation = &RowsMockFieldDescriptionsExpectation{mock: mmFieldDescriptions.mock}
	}
	mmFieldDescriptions.defaultExpectation.results = &RowsMockFieldDescriptionsResults{fa1}
	mmFieldDescriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFieldDescriptions.mock
}

// Set uses given function f to mock the Rows.FieldDescriptions method
func (mmFieldDescriptions *mRowsMockFieldDescriptions) Set(f func() (fa1 []pgproto3.FieldDescription)) *RowsMock {
	if mmFieldDescriptions.defaultExpectation != nil {
		mmFieldDescriptions.mock.t.Fatalf("Default expectation is already set for the Rows.FieldDescriptions method")
	}

	if len(mmFieldDescriptions.expectations) > 0 {
		mmFieldDescriptions.mock.t.Fatalf("Some expectations are already set for the Rows.FieldDescriptions method")
	}

	mmFieldDescriptions.mock.funcFieldDescriptions = f
	mmFieldDescriptions.mock.funcFieldDescriptionsOrigin = minimock.CallerInfo(1)
	return mmFieldDescriptions.mock
}

// Times sets number of times Rows.FieldDescriptions should be invoked
func (mmFieldDescriptions *mRowsMockFieldDescriptions) Times(n uint64) *mRowsMockFieldDescriptions {
	if n == 0 {
		mmFieldDescriptions.mock.t.Fatalf("Times of RowsMock.FieldDescriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFieldDescriptions.expectedInvocations, n)
	mmFieldDescriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFieldDescriptions
}

func (mmFieldDescriptions *mRowsMockFieldDescriptions) invocationsDone() bool {
	if len(mmFieldDescriptions.expectations) == 0 && mmFieldDescriptions.defaultExpectation == nil && mmFieldDescriptions.mock.funcFieldDescriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFieldDescriptions.mock.afterFieldDescriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFieldDescriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FieldDescriptions implements mm_pgx.Rows
func (mmFieldDescriptions *RowsMock) FieldDescriptions() (fa1 []pgproto3.FieldDescription) {
	mm_atomic.AddUint64(&mmFieldDescriptions.beforeFieldDescriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmFieldDescriptions.afterFieldDescriptionsCounter, 1)

	mmFieldDescriptions.t.Helper()

	if mmFieldDescriptions.inspectFuncFieldDescriptions != nil {
		mmFieldDescriptions.inspectFuncFieldDescriptions()
	}

	if mmFieldDescriptions.FieldDescriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFieldDescriptions.FieldDescriptionsMock.defaultExpectation.Counter, 1)

		mm_results := mmFieldDescriptions.FieldDescriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmFieldDescriptions.t.Fatal("No results are set for the RowsMock.FieldDescriptions")
		}
		return (*mm_results).fa1
	}
	if mmFieldDescriptions.funcFieldDescriptions != nil {
		return mmFieldDescriptions.funcFieldDescriptions()
	}
	mmFieldDescriptions.t.Fatalf("Unexpected call to RowsMock.FieldDescriptions.")
	return
}

// FieldDescriptionsAfterCounter returns a count of finished RowsMock.FieldDescriptions invocations
func (mmFieldDescriptions *RowsMock) FieldDescriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFieldDescriptions.afterFieldDescriptionsCounter)
}

// FieldDescriptionsBeforeCounter returns a count of RowsMock.FieldDescriptions invocations
func (mmFieldDescriptions *RowsMock) FieldDescriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFieldDescriptions.beforeFieldDescriptionsCounter)
}

// MinimockFieldDescriptionsDone returns true if the count of the FieldDescriptions invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockFieldDescriptionsDone() bool {
	if m.FieldDescriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FieldDescriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FieldDescriptionsMock.invocationsDone()
}

// MinimockFieldDescriptionsInspect logs each unmet expectation
func (m *RowsMock) MinimockFieldDescriptionsInspect() {
	for _, e := range m.FieldDescriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.FieldDescriptions")
		}
	}

	afterFieldDescriptionsCounter := mm_atomic.LoadUint64(&m.afterFieldDescriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FieldDescriptionsMock.defaultExpectation != nil && afterFieldDescriptionsCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.FieldDescriptions at\n%s", m.FieldDescriptionsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFieldDescriptions != nil && afterFieldDescriptionsCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.FieldDescriptions at\n%s", m.funcFieldDescriptionsOrigin)
	}

	if !m.FieldDescriptionsMock.invocationsDone() && afterFieldDescriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.FieldDescriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FieldDescriptionsMock.expectedInvocations), m.FieldDescriptionsMock.expectedInvocationsOrigin, afterFieldDescriptionsCounter)
	}
}

type mRowsMockNext struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockNextExpectation
	expectations       []*RowsMockNextExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockNextExpectation specifies expectation struct of the Rows.Next
type RowsMockNextExpectation struct {
	mock *RowsMock

	results      *RowsMockNextResults
	returnOrigin string
	Counter      uint64
}

// RowsMockNextResults contains results of the Rows.Next
type RowsMockNextResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNext *mRowsMockNext) Optional() *mRowsMockNext {
	mmNext.optional = true
	return mmNext
}

// Expect sets up expected params for Rows.Next
func (mmNext *mRowsMockNext) Expect() *mRowsMockNext {
	if mmNext.mock.funcNext != nil {
		mmNext.mock.t.Fatalf("RowsMock.Next mock is already set by Set")
	}

	if mmNext.defaultExpectation == nil {
		mmNext.defaultExpectation = &RowsMockNextExpectation{}
	}

	return mmNext
}

// Inspect accepts an inspector function that has same arguments as the Rows.Next
func (mmNext *mRowsMockNext) Inspect(f func()) *mRowsMockNext {
	if mmNext.mock.inspectFuncNext != nil {
		mmNext.mock.t.Fatalf("Inspect function is already set for RowsMock.Next")
	}

	mmNext.mock.inspectFuncNext = f

	return mmNext
}

// Return sets up results that will be returned by Rows.Next
func (mmNext *mRowsMockNext) Return(b1 bool) *RowsMock {
	if mmNext.mock.funcNext != nil {
		mmNext.mock.t.Fatalf("RowsMock.Next mock is already set by Set")
	}

	if mmNext.defaultExpectation == nil {
		mmNext.defaultExpectation = &RowsMockNextExpectation{mock: mmNext.mock}
	}
	mmNext.defaultExpectation.results = &RowsMockNextResults{b1}
	mmNext.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNext.mock
}

// Set uses given function f to mock the Rows.Next method
func (mmNext *mRowsMockNext) Set(f func() (b1 bool)) *RowsMock {
	if mmNext.defaultExpectation != nil {
		mmNext.mock.t.Fatalf("Default expectation is already set for the Rows.Next method")
	}

	if len(mmNext.expectations) > 0 {
		mmNext.mock.t.Fatalf("Some expectations are already set for the Rows.Next method")
	}

	mmNext.mock.funcNext = f
	mmNext.mock.funcNextOrigin = minimock.CallerInfo(1)
	return mmNext.mock
}

// Times sets number of times Rows.Next should be invoked
func (mmNext *mRowsMockNext) Times(n uint64) *mRowsMockNext {
	if n == 0 {
		mmNext.mock.t.Fatalf("Times of RowsMock.Next mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNext.expectedInvocations, n)
	mmNext.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNext
}

func (mmNext *mRowsMockNext) invocationsDone() bool {
	if len(mmNext.expectations) == 0 && mmNext.defaultExpectation == nil && mmNext.mock.funcNext == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNext.mock.afterNextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNext.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Next implements mm_pgx.Rows
func (mmNext *RowsMock) Next() (b1 bool) {
	mm_atomic.AddUint64(&mmNext.beforeNextCounter, 1)
	defer mm_atomic.AddUint64(&mmNext.afterNextCounter, 1)

	mmNext.t.Helper()

	if mmNext.inspectFuncNext != nil {
		mmNext.inspectFuncNext()
	}

	if mmNext.NextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNext.NextMock.defaultExpectation.Counter, 1)

		mm_results := mmNext.NextMock.defaultExpectation.results
		if mm_results == nil {
			mmNext.t.Fatal("No results are set for the RowsMock.Next")
		}
		return (*mm_results).b1
	}
	if mmNext.funcNext != nil {
		return mmNext.funcNext()
	}
	mmNext.t.Fatalf("Unexpected call to RowsMock.Next.")
	return
}

// NextAfterCounter returns a count of finished RowsMock.Next invocations
func (mmNext *RowsMock) NextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNext.afterNextCounter)
}

// NextBeforeCounter returns a count of RowsMock.Next invocations
func (mmNext *RowsMock) NextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNext.beforeNextCounter)
}

// MinimockNextDone returns true if the count of the Next invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockNextDone() bool {
	if m.NextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NextMock.invocationsDone()
}

// MinimockNextInspect logs each unmet expectation
func (m *RowsMock) MinimockNextInspect() {
	for _, e := range m.NextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.Next")
		}
	}

	afterNextCounter := mm_atomic.LoadUint64(&m.afterNextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NextMock.defaultExpectation != nil && afterNextCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Next at\n%s", m.NextMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNext != nil && afterNextCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Next at\n%s", m.funcNextOrigin)
	}

	if !m.NextMock.invocationsDone() && afterNextCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.Next at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NextMock.expectedInvocations), m.NextMock.expectedInvocationsOrigin, afterNextCounter)
	}
}

type mRowsMockRawValues struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockRawValuesExpectation
	expectations       []*RowsMockRawValuesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockRawValuesExpectation specifies expectation struct of the Rows.RawValues
type RowsMockRawValuesExpectation struct {
	mock *RowsMock

	results      *RowsMockRawValuesResults
	returnOrigin string
	Counter      uint64
}

// RowsMockRawValuesResults contains results of the Rows.RawValues
type RowsMockRawValuesResults struct {
	baa1 [][]byte
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRawValues *mRowsMockRawValues) Optional() *mRowsMockRawValues {
	mmRawValues.optional = true
	return mmRawValues
}

// Expect sets up expected params for Rows.RawValues
func (mmRawValues *mRowsMockRawValues) Expect() *mRowsMockRawValues {
	if mmRawValues.mock.funcRawValues != nil {
		mmRawValues.mock.t.Fatalf("RowsMock.RawValues mock is already set by Set")
	}

	if mmRawValues.defaultExpectation == nil {
		mmRawValues.defaultExpectation = &RowsMockRawValuesExpectation{}
	}

	return mmRawValues
}

// Inspect accepts an inspector function that has same arguments as the Rows.RawValues
func (mmRawValues *mRowsMockRawValues) Inspect(f func()) *mRowsMockRawValues {
	if mmRawValues.mock.inspectFuncRawValues != nil {
		mmRawValues.mock.t.Fatalf("Inspect function is already set for RowsMock.RawValues")
	}

	mmRawValues.mock.inspectFuncRawValues = f

	return mmRawValues
}

// Return sets up results that will be returned by Rows.RawValues
func (mmRawValues *mRowsMockRawValues) Return(baa1 [][]byte) *RowsMock {
	if mmRawValues.mock.funcRawValues != nil {
		mmRawValues.mock.t.Fatalf("RowsMock.RawValues mock is already set by Set")
	}

	if mmRawValues.defaultExpectation == nil {
		mmRawValues.defaultExpectation = &RowsMockRawValuesExpectation{mock: mmRawValues.mock}
	}
	mmRawValues.defaultExpectation.results = &RowsMockRawValuesResults{baa1}
	mmRawValues.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRawValues.mock
}

// Set uses given function f to mock the Rows.RawValues method
func (mmRawValues *mRowsMockRawValues) Set(f func() (baa1 [][]byte)) *RowsMock {
	if mmRawValues.defaultExpectation != nil {
		mmRawValues.mock.t.Fatalf("Default expectation is already set for the Rows.RawValues method")
	}

	if len(mmRawValues.expectations) > 0 {
		mmRawValues.mock.t.Fatalf("Some expectations are already set for the Rows.RawValues method")
	}

	mmRawValues.mock.funcRawValues = f
	mmRawValues.mock.funcRawValuesOrigin = minimock.CallerInfo(1)
	return mmRawValues.mock
}

// Times sets number of times Rows.RawValues should be invoked
func (mmRawValues *mRowsMockRawValues) Times(n uint64) *mRowsMockRawValues {
	if n == 0 {
		mmRawValues.mock.t.Fatalf("Times of RowsMock.RawValues mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRawValues.expectedInvocations, n)
	mmRawValues.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRawValues
}

func (mmRawValues *mRowsMockRawValues) invocationsDone() bool {
	if len(mmRawValues.expectations) == 0 && mmRawValues.defaultExpectation == nil && mmRawValues.mock.funcRawValues == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRawValues.mock.afterRawValuesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRawValues.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RawValues implements mm_pgx.Rows
func (mmRawValues *RowsMock) RawValues() (baa1 [][]byte) {
	mm_atomic.AddUint64(&mmRawValues.beforeRawValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmRawValues.afterRawValuesCounter, 1)

	mmRawValues.t.Helper()

	if mmRawValues.inspectFuncRawValues != nil {
		mmRawValues.inspectFuncRawValues()
	}

	if mmRawValues.RawValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRawValues.RawValuesMock.defaultExpectation.Counter, 1)

		mm_results := mmRawValues.RawValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmRawValues.t.Fatal("No results are set for the RowsMock.RawValues")
		}
		return (*mm_results).baa1
	}
	if mmRawValues.funcRawValues != nil {
		return mmRawValues.funcRawValues()
	}
	mmRawValues.t.Fatalf("Unexpected call to RowsMock.RawValues.")
	return
}

// RawValuesAfterCounter returns a count of finished RowsMock.RawValues invocations
func (mmRawValues *RowsMock) RawValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRawValues.afterRawValuesCounter)
}

// RawValuesBeforeCounter returns a count of RowsMock.RawValues invocations
func (mmRawValues *RowsMock) RawValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRawValues.beforeRawValuesCounter)
}

// MinimockRawValuesDone returns true if the count of the RawValues invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockRawValuesDone() bool {
	if m.RawValuesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RawValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RawValuesMock.invocationsDone()
}

// MinimockRawValuesInspect logs each unmet expectation
func (m *RowsMock) MinimockRawValuesInspect() {
	for _, e := range m.RawValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.RawValues")
		}
	}

	afterRawValuesCounter := mm_atomic.LoadUint64(&m.afterRawValuesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RawValuesMock.defaultExpectation != nil && afterRawValuesCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.RawValues at\n%s", m.RawValuesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRawValues != nil && afterRawValuesCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.RawValues at\n%s", m.funcRawValuesOrigin)
	}

	if !m.RawValuesMock.invocationsDone() && afterRawValuesCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.RawValues at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RawValuesMock.expectedInvocations), m.RawValuesMock.expectedInvocationsOrigin, afterRawValuesCounter)
	}
}

type mRowsMockScan struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockScanExpectation
	expectations       []*RowsMockScanExpectation

	callArgs []*RowsMockScanParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockScanExpectation specifies expectation struct of the Rows.Scan
type RowsMockScanExpectation struct {
	mock               *RowsMock
	params             *RowsMockScanParams
	paramPtrs          *RowsMockScanParamPtrs
	expectationOrigins RowsMockScanExpectationOrigins
	results            *RowsMockScanResults
	returnOrigin       string
	Counter            uint64
}

// RowsMockScanParams contains parameters of the Rows.Scan
type RowsMockScanParams struct {
	dest []interface{}
}

// RowsMockScanParamPtrs contains pointers to parameters of the Rows.Scan
type RowsMockScanParamPtrs struct {
	dest *[]interface{}
}

// RowsMockScanResults contains results of the Rows.Scan
type RowsMockScanResults struct {
	err error
}

// RowsMockScanOrigins contains origins of expectations of the Rows.Scan
type RowsMockScanExpectationOrigins struct {
	origin     string
	originDest string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScan *mRowsMockScan) Optional() *mRowsMockScan {
	mmScan.optional = true
	return mmScan
}

// Expect sets up expected params for Rows.Scan
func (mmScan *mRowsMockScan) Expect(dest ...interface{}) *mRowsMockScan {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("RowsMock.Scan mock is already set by Set")
	}

	if mmScan.defaultExpectation == nil {
		mmScan.defaultExpectation = &RowsMockScanExpectation{}
	}

	if mmScan.defaultExpectation.paramPtrs != nil {
		mmScan.mock.t.Fatalf("RowsMock.Scan mock is already set by ExpectParams functions")
	}

	mmScan.defaultExpectation.params = &RowsMockScanParams{dest}
	mmScan.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScan.expectations {
		if minimock.Equal(e.params, mmScan.defaultExpectation.params) {
			mmScan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScan.defaultExpectation.params)
		}
	}

	return mmScan
}

// ExpectDestParam1 sets up expected param dest for Rows.Scan
func (mmScan *mRowsMockScan) ExpectDestParam1(dest ...interface{}) *mRowsMockScan {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("RowsMock.Scan mock is already set by Set")
	}

	if mmScan.defaultExpectation == nil {
		mmScan.defaultExpectation = &RowsMockScanExpectation{}
	}

	if mmScan.defaultExpectation.params != nil {
		mmScan.mock.t.Fatalf("RowsMock.Scan mock is already set by Expect")
	}

	if mmScan.defaultExpectation.paramPtrs == nil {
		mmScan.defaultExpectation.paramPtrs = &RowsMockScanParamPtrs{}
	}
	mmScan.defaultExpectation.paramPtrs.dest = &dest
	mmScan.defaultExpectation.expectationOrigins.originDest = minimock.CallerInfo(1)

	return mmScan
}

// Inspect accepts an inspector function that has same arguments as the Rows.Scan
func (mmScan *mRowsMockScan) Inspect(f func(dest ...interface{})) *mRowsMockScan {
	if mmScan.mock.inspectFuncScan != nil {
		mmScan.mock.t.Fatalf("Inspect function is already set for RowsMock.Scan")
	}

	mmScan.mock.inspectFuncScan = f

	return mmScan
}

// Return sets up results that will be returned by Rows.Scan
func (mmScan *mRowsMockScan) Return(err error) *RowsMock {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("RowsMock.Scan mock is already set by Set")
	}

	if mmScan.defaultExpectation == nil {
		mmScan.defaultExpectation = &RowsMockScanExpectation{mock: mmScan.mock}
	}
	mmScan.defaultExpectation.results = &RowsMockScanResults{err}
	mmScan.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScan.mock
}

// Set uses given function f to mock the Rows.Scan method
func (mmScan *mRowsMockScan) Set(f func(dest ...interface{}) (err error)) *RowsMock {
	if mmScan.defaultExpectation != nil {
		mmScan.mock.t.Fatalf("Default expectation is already set for the Rows.Scan method")
	}

	if len(mmScan.expectations) > 0 {
		mmScan.mock.t.Fatalf("Some expectations are already set for the Rows.Scan method")
	}

	mmScan.mock.funcScan = f
	mmScan.mock.funcScanOrigin = minimock.CallerInfo(1)
	return mmScan.mock
}

// When sets expectation for the Rows.Scan which will trigger the result defined by the following
// Then helper
func (mmScan *mRowsMockScan) When(dest ...interface{}) *RowsMockScanExpectation {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("RowsMock.Scan mock is already set by Set")
	}

	expectation := &RowsMockScanExpectation{
		mock:               mmScan.mock,
		params:             &RowsMockScanParams{dest},
		expectationOrigins: RowsMockScanExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScan.expectations = append(mmScan.expectations, expectation)
	return expectation
}

// Then sets up Rows.Scan return parameters for the expectation previously defined by the When method
func (e *RowsMockScanExpectation) Then(err error) *RowsMock {
	e.results = &RowsMockScanResults{err}
	return e.mock
}

// Times sets number of times Rows.Scan should be invoked
func (mmScan *mRowsMockScan) Times(n uint64) *mRowsMockScan {
	if n == 0 {
		mmScan.mock.t.Fatalf("Times of RowsMock.Scan mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScan.expectedInvocations, n)
	mmScan.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScan
}

func (mmScan *mRowsMockScan) invocationsDone() bool {
	if len(mmScan.expectations) == 0 && mmScan.defaultExpectation == nil && mmScan.mock.funcScan == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScan.mock.afterScanCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScan.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Scan implements mm_pgx.Rows
func (mmScan *RowsMock) Scan(dest ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScan.beforeScanCounter, 1)
	defer mm_atomic.AddUint64(&mmScan.afterScanCounter, 1)

	mmScan.t.Helper()

	if mmScan.inspectFuncScan != nil {
		mmScan.inspectFuncScan(dest...)
	}

	mm_params := RowsMockScanParams{dest}

	// Record call args
	mmScan.ScanMock.mutex.Lock()
	mmScan.ScanMock.callArgs = append(mmScan.ScanMock.callArgs, &mm_params)
	mmScan.ScanMock.mutex.Unlock()

	for _, e := range mmScan.ScanMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScan.ScanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScan.ScanMock.defaultExpectation.Counter, 1)
		mm_want := mmScan.ScanMock.defaultExpectation.params
		mm_want_ptrs := mmScan.ScanMock.defaultExpectation.paramPtrs

		mm_got := RowsMockScanParams{dest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.dest != nil && !minimock.Equal(*mm_want_ptrs.dest, mm_got.dest) {
				mmScan.t.Errorf("RowsMock.Scan got unexpected parameter dest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScan.ScanMock.defaultExpectation.expectationOrigins.originDest, *mm_want_ptrs.dest, mm_got.dest, minimock.Diff(*mm_want_ptrs.dest, mm_got.dest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScan.t.Errorf("RowsMock.Scan got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScan.ScanMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScan.ScanMock.defaultExpectation.results
		if mm_results == nil {
			mmScan.t.Fatal("No results are set for the RowsMock.Scan")
		}
		return (*mm_results).err
	}
	if mmScan.funcScan != nil {
		return mmScan.funcScan(dest...)
	}
	mmScan.t.Fatalf("Unexpected call to RowsMock.Scan. %v", dest)
	return
}

// ScanAfterCounter returns a count of finished RowsMock.Scan invocations
func (mmScan *RowsMock) ScanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScan.afterScanCounter)
}

// ScanBeforeCounter returns a count of RowsMock.Scan invocations
func (mmScan *RowsMock) ScanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScan.beforeScanCounter)
}

// Calls returns a list of arguments used in each call to RowsMock.Scan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScan *mRowsMockScan) Calls() []*RowsMockScanParams {
	mmScan.mutex.RLock()

	argCopy := make([]*RowsMockScanParams, len(mmScan.callArgs))
	copy(argCopy, mmScan.callArgs)

	mmScan.mutex.RUnlock()

	return argCopy
}

// MinimockScanDone returns true if the count of the Scan invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockScanDone() bool {
	if m.ScanMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanMock.invocationsDone()
}

// MinimockScanInspect logs each unmet expectation
func (m *RowsMock) MinimockScanInspect() {
	for _, e := range m.ScanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RowsMock.Scan at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanCounter := mm_atomic.LoadUint64(&m.afterScanCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanMock.defaultExpectation != nil && afterScanCounter < 1 {
		if m.ScanMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RowsMock.Scan at\n%s", m.ScanMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RowsMock.Scan at\n%s with params: %#v", m.ScanMock.defaultExpectation.expectationOrigins.origin, *m.ScanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScan != nil && afterScanCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Scan at\n%s", m.funcScanOrigin)
	}

	if !m.ScanMock.invocationsDone() && afterScanCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.Scan at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanMock.expectedInvocations), m.ScanMock.expectedInvocationsOrigin, afterScanCounter)
	}
}

type mRowsMockValues struct {
	optional           bool
	mock               *RowsMock
	defaultExpectation *RowsMockValuesExpectation
	expectations       []*RowsMockValuesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RowsMockValuesExpectation specifies expectation struct of the Rows.Values
type RowsMockValuesExpectation struct {
	mock *RowsMock

	results      *RowsMockValuesResults
	returnOrigin string
	Counter      uint64
}

// RowsMockValuesResults contains results of the Rows.Values
type RowsMockValuesResults struct {
	pa1 []interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValues *mRowsMockValues) Optional() *mRowsMockValues {
	mmValues.optional = true
	return mmValues
}

// Expect sets up expected params for Rows.Values
func (mmValues *mRowsMockValues) Expect() *mRowsMockValues {
	if mmValues.mock.funcValues != nil {
		mmValues.mock.t.Fatalf("RowsMock.Values mock is already set by Set")
	}

	if mmValues.defaultExpectation == nil {
		mmValues.defaultExpectation = &RowsMockValuesExpectation{}
	}

	return mmValues
}

// Inspect accepts an inspector function that has same arguments as the Rows.Values
func (mmValues *mRowsMockValues) Inspect(f func()) *mRowsMockValues {
	if mmValues.mock.inspectFuncValues != nil {
		mmValues.mock.t.Fatalf("Inspect function is already set for RowsMock.Values")
	}

	mmValues.mock.inspectFuncValues = f

	return mmValues
}

// Return sets up results that will be returned by Rows.Values
func (mmValues *mRowsMockValues) Return(pa1 []interface{}, err error) *RowsMock {
	if mmValues.mock.funcValues != nil {
		mmValues.mock.t.Fatalf("RowsMock.Values mock is already set by Set")
	}

	if mmValues.defaultExpectation == nil {
		mmValues.defaultExpectation = &RowsMockValuesExpectation{mock: mmValues.mock}
	}
	mmValues.defaultExpectation.results = &RowsMockValuesResults{pa1, err}
	mmValues.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValues.mock
}

// Set uses given function f to mock the Rows.Values method
func (mmValues *mRowsMockValues) Set(f func() (pa1 []interface{}, err error)) *RowsMock {
	if mmValues.defaultExpectation != nil {
		mmValues.mock.t.Fatalf("Default expectation is already set for the Rows.Values method")
	}

	if len(mmValues.expectations) > 0 {
		mmValues.mock.t.Fatalf("Some expectations are already set for the Rows.Values method")
	}

	mmValues.mock.funcValues = f
	mmValues.mock.funcValuesOrigin = minimock.CallerInfo(1)
	return mmValues.mock
}

// Times sets number of times Rows.Values should be invoked
func (mmValues *mRowsMockValues) Times(n uint64) *mRowsMockValues {
	if n == 0 {
		mmValues.mock.t.Fatalf("Times of RowsMock.Values mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValues.expectedInvocations, n)
	mmValues.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValues
}

func (mmValues *mRowsMockValues) invocationsDone() bool {
	if len(mmValues.expectations) == 0 && mmValues.defaultExpectation == nil && mmValues.mock.funcValues == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValues.mock.afterValuesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValues.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Values implements mm_pgx.Rows
func (mmValues *RowsMock) Values() (pa1 []interface{}, err error) {
	mm_atomic.AddUint64(&mmValues.beforeValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmValues.afterValuesCounter, 1)

	mmValues.t.Helper()

	if mmValues.inspectFuncValues != nil {
		mmValues.inspectFuncValues()
	}

	if mmValues.ValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValues.ValuesMock.defaultExpectation.Counter, 1)

		mm_results := mmValues.ValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmValues.t.Fatal("No results are set for the RowsMock.Values")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmValues.funcValues != nil {
		return mmValues.funcValues()
	}
	mmValues.t.Fatalf("Unexpected call to RowsMock.Values.")
	return
}

// ValuesAfterCounter returns a count of finished RowsMock.Values invocations
func (mmValues *RowsMock) ValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValues.afterValuesCounter)
}

// ValuesBeforeCounter returns a count of RowsMock.Values invocations
func (mmValues *RowsMock) ValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValues.beforeValuesCounter)
}

// MinimockValuesDone returns true if the count of the Values invocations corresponds
// the number of defined expectations
func (m *RowsMock) MinimockValuesDone() bool {
	if m.ValuesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValuesMock.invocationsDone()
}

// MinimockValuesInspect logs each unmet expectation
func (m *RowsMock) MinimockValuesInspect() {
	for _, e := range m.ValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RowsMock.Values")
		}
	}

	afterValuesCounter := mm_atomic.LoadUint64(&m.afterValuesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValuesMock.defaultExpectation != nil && afterValuesCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Values at\n%s", m.ValuesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValues != nil && afterValuesCounter < 1 {
		m.t.Errorf("Expected call to RowsMock.Values at\n%s", m.funcValuesOrigin)
	}

	if !m.ValuesMock.invocationsDone() && afterValuesCounter > 0 {
		m.t.Errorf("Expected %d calls to RowsMock.Values at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValuesMock.expectedInvocations), m.ValuesMock.expectedInvocationsOrigin, afterValuesCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RowsMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockCommandTagInspect()

			m.MinimockErrInspect()

			m.MinimockFieldDescriptionsInspect()

			m.MinimockNextInspect()

			m.MinimockRawValuesInspect()

			m.MinimockScanInspect()

			m.MinimockValuesInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RowsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RowsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockCommandTagDone() &&
		m.MinimockErrDone() &&
		m.MinimockFieldDescriptionsDone() &&
		m.MinimockNextDone() &&
		m.MinimockRawValuesDone() &&
		m.MinimockScanDone() &&
		m.MinimockValuesDone()
}
