// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/jackc/pgx/v4.Tx -o tx_mock.go -n TXMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	mm_pgx "github.com/jackc/pgx/v4"
)

// TXMock implements mm_pgx.Tx
type TXMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func(ctx context.Context) (t1 mm_pgx.Tx, err error)
	funcBeginOrigin    string
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mTXMockBegin

	funcBeginFunc          func(ctx context.Context, f func(mm_pgx.Tx) error) (err error)
	funcBeginFuncOrigin    string
	inspectFuncBeginFunc   func(ctx context.Context, f func(mm_pgx.Tx) error)
	afterBeginFuncCounter  uint64
	beforeBeginFuncCounter uint64
	BeginFuncMock          mTXMockBeginFunc

	funcCommit          func(ctx context.Context) (err error)
	funcCommitOrigin    string
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTXMockCommit

	funcConn          func() (cp1 *mm_pgx.Conn)
	funcConnOrigin    string
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mTXMockConn

	funcCopyFrom          func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)
	funcCopyFromOrigin    string
	inspectFuncCopyFrom   func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mTXMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)
	funcExecOrigin    string
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mTXMockExec

	funcLargeObjects          func() (l1 mm_pgx.LargeObjects)
	funcLargeObjectsOrigin    string
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mTXMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	funcPrepareOrigin    string
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mTXMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Rows, err error)
	funcQueryOrigin    string
	inspectFuncQuery   func(ctx context.Context, sql string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mTXMockQuery

	funcQueryFunc          func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)
	funcQueryFuncOrigin    string
	inspectFuncQueryFunc   func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error)
	afterQueryFuncCounter  uint64
	beforeQueryFuncCounter uint64
	QueryFuncMock          mTXMockQueryFunc

	funcQueryRow          func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Row)
	funcQueryRowOrigin    string
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...interface{})
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mTXMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	funcRollbackOrigin    string
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTXMockRollback

	funcSendBatch          func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)
	funcSendBatchOrigin    string
	inspectFuncSendBatch   func(ctx context.Context, b *mm_pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mTXMockSendBatch
}

// NewTXMock returns a mock for mm_pgx.Tx
func NewTXMock(t minimock.Tester) *TXMock {
	m := &TXMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mTXMockBegin{mock: m}
	m.BeginMock.callArgs = []*TXMockBeginParams{}

	m.BeginFuncMock = mTXMockBeginFunc{mock: m}
	m.BeginFuncMock.callArgs = []*TXMockBeginFuncParams{}

	m.CommitMock = mTXMockCommit{mock: m}
	m.CommitMock.callArgs = []*TXMockCommitParams{}

	m.ConnMock = mTXMockConn{mock: m}

	m.CopyFromMock = mTXMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*TXMockCopyFromParams{}

	m.ExecMock = mTXMockExec{mock: m}
	m.ExecMock.callArgs = []*TXMockExecParams{}

	m.LargeObjectsMock = mTXMockLargeObjects{mock: m}

	m.PrepareMock = mTXMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*TXMockPrepareParams{}

	m.QueryMock = mTXMockQuery{mock: m}
	m.QueryMock.callArgs = []*TXMockQueryParams{}

	m.QueryFuncMock = mTXMockQueryFunc{mock: m}
	m.QueryFuncMock.callArgs = []*TXMockQueryFuncParams{}

	m.QueryRowMock = mTXMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*TXMockQueryRowParams{}

	m.RollbackMock = mTXMockRollback{mock: m}
	m.RollbackMock.callArgs = []*TXMockRollbackParams{}

	m.SendBatchMock = mTXMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*TXMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTXMockBegin struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockBeginExpectation
	expectations       []*TXMockBeginExpectation

	callArgs []*TXMockBeginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockBeginExpectation specifies expectation struct of the Tx.Begin
type TXMockBeginExpectation struct {
	mock               *TXMock
	params             *TXMockBeginParams
	paramPtrs          *TXMockBeginParamPtrs
	expectationOrigins TXMockBeginExpectationOrigins
	results            *TXMockBeginResults
	returnOrigin       string
	Counter            uint64
}

// TXMockBeginParams contains parameters of the Tx.Begin
type TXMockBeginParams struct {
	ctx context.Context
}

// TXMockBeginParamPtrs contains pointers to parameters of the Tx.Begin
type TXMockBeginParamPtrs struct {
	ctx *context.Context
}

// TXMockBeginResults contains results of the Tx.Begin
type TXMockBeginResults struct {
	t1  mm_pgx.Tx
	err error
}

// TXMockBeginOrigins contains origins of expectations of the Tx.Begin
type TXMockBeginExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mTXMockBegin) Optional() *mTXMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for Tx.Begin
func (mmBegin *mTXMockBegin) Expect(ctx context.Context) *mTXMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TXMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TXMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.paramPtrs != nil {
		mmBegin.mock.t.Fatalf("TXMock.Begin mock is already set by ExpectParams functions")
	}

	mmBegin.defaultExpectation.params = &TXMockBeginParams{ctx}
	mmBegin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Begin
func (mmBegin *mTXMockBegin) ExpectCtxParam1(ctx context.Context) *mTXMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TXMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TXMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.params != nil {
		mmBegin.mock.t.Fatalf("TXMock.Begin mock is already set by Expect")
	}

	if mmBegin.defaultExpectation.paramPtrs == nil {
		mmBegin.defaultExpectation.paramPtrs = &TXMockBeginParamPtrs{}
	}
	mmBegin.defaultExpectation.paramPtrs.ctx = &ctx
	mmBegin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Tx.Begin
func (mmBegin *mTXMockBegin) Inspect(f func(ctx context.Context)) *mTXMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for TXMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Tx.Begin
func (mmBegin *mTXMockBegin) Return(t1 mm_pgx.Tx, err error) *TXMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TXMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TXMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &TXMockBeginResults{t1, err}
	mmBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Set uses given function f to mock the Tx.Begin method
func (mmBegin *mTXMockBegin) Set(f func(ctx context.Context) (t1 mm_pgx.Tx, err error)) *TXMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Tx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Tx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	mmBegin.mock.funcBeginOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// When sets expectation for the Tx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mTXMockBegin) When(ctx context.Context) *TXMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TXMock.Begin mock is already set by Set")
	}

	expectation := &TXMockBeginExpectation{
		mock:               mmBegin.mock,
		params:             &TXMockBeginParams{ctx},
		expectationOrigins: TXMockBeginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Tx.Begin return parameters for the expectation previously defined by the When method
func (e *TXMockBeginExpectation) Then(t1 mm_pgx.Tx, err error) *TXMock {
	e.results = &TXMockBeginResults{t1, err}
	return e.mock
}

// Times sets number of times Tx.Begin should be invoked
func (mmBegin *mTXMockBegin) Times(n uint64) *mTXMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of TXMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	mmBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBegin
}

func (mmBegin *mTXMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements mm_pgx.Tx
func (mmBegin *TXMock) Begin(ctx context.Context) (t1 mm_pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	mmBegin.t.Helper()

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := TXMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, &mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_want_ptrs := mmBegin.BeginMock.defaultExpectation.paramPtrs

		mm_got := TXMockBeginParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBegin.t.Errorf("TXMock.Begin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBegin.BeginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("TXMock.Begin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBegin.BeginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the TXMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to TXMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished TXMock.Begin invocations
func (mmBegin *TXMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of TXMock.Begin invocations
func (mmBegin *TXMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to TXMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mTXMockBegin) Calls() []*TXMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*TXMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *TXMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.Begin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.Begin at\n%s", m.BeginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.Begin at\n%s with params: %#v", m.BeginMock.defaultExpectation.expectationOrigins.origin, *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Begin at\n%s", m.funcBeginOrigin)
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Begin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), m.BeginMock.expectedInvocationsOrigin, afterBeginCounter)
	}
}

type mTXMockBeginFunc struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockBeginFuncExpectation
	expectations       []*TXMockBeginFuncExpectation

	callArgs []*TXMockBeginFuncParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockBeginFuncExpectation specifies expectation struct of the Tx.BeginFunc
type TXMockBeginFuncExpectation struct {
	mock               *TXMock
	params             *TXMockBeginFuncParams
	paramPtrs          *TXMockBeginFuncParamPtrs
	expectationOrigins TXMockBeginFuncExpectationOrigins
	results            *TXMockBeginFuncResults
	returnOrigin       string
	Counter            uint64
}

// TXMockBeginFuncParams contains parameters of the Tx.BeginFunc
type TXMockBeginFuncParams struct {
	ctx context.Context
	f   func(mm_pgx.Tx) error
}

// TXMockBeginFuncParamPtrs contains pointers to parameters of the Tx.BeginFunc
type TXMockBeginFuncParamPtrs struct {
	ctx *context.Context
	f   *func(mm_pgx.Tx) error
}

// TXMockBeginFuncResults contains results of the Tx.BeginFunc
type TXMockBeginFuncResults struct {
	err error
}

// TXMockBeginFuncOrigins contains origins of expectations of the Tx.BeginFunc
type TXMockBeginFuncExpectationOrigins struct {
	origin    string
	originCtx string
	originF   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBeginFunc *mTXMockBeginFunc) Optional() *mTXMockBeginFunc {
	mmBeginFunc.optional = true
	return mmBeginFunc
}

// Expect sets up expected params for Tx.BeginFunc
func (mmBeginFunc *mTXMockBeginFunc) Expect(ctx context.Context, f func(mm_pgx.Tx) error) *mTXMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TXMockBeginFuncExpectation{}
	}

	if mmBeginFunc.defaultExpectation.paramPtrs != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by ExpectParams functions")
	}

	mmBeginFunc.defaultExpectation.params = &TXMockBeginFuncParams{ctx, f}
	mmBeginFunc.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBeginFunc.expectations {
		if minimock.Equal(e.params, mmBeginFunc.defaultExpectation.params) {
			mmBeginFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginFunc.defaultExpectation.params)
		}
	}

	return mmBeginFunc
}

// ExpectCtxParam1 sets up expected param ctx for Tx.BeginFunc
func (mmBeginFunc *mTXMockBeginFunc) ExpectCtxParam1(ctx context.Context) *mTXMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TXMockBeginFuncExpectation{}
	}

	if mmBeginFunc.defaultExpectation.params != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Expect")
	}

	if mmBeginFunc.defaultExpectation.paramPtrs == nil {
		mmBeginFunc.defaultExpectation.paramPtrs = &TXMockBeginFuncParamPtrs{}
	}
	mmBeginFunc.defaultExpectation.paramPtrs.ctx = &ctx
	mmBeginFunc.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBeginFunc
}

// ExpectFParam2 sets up expected param f for Tx.BeginFunc
func (mmBeginFunc *mTXMockBeginFunc) ExpectFParam2(f func(mm_pgx.Tx) error) *mTXMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TXMockBeginFuncExpectation{}
	}

	if mmBeginFunc.defaultExpectation.params != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Expect")
	}

	if mmBeginFunc.defaultExpectation.paramPtrs == nil {
		mmBeginFunc.defaultExpectation.paramPtrs = &TXMockBeginFuncParamPtrs{}
	}
	mmBeginFunc.defaultExpectation.paramPtrs.f = &f
	mmBeginFunc.defaultExpectation.expectationOrigins.originF = minimock.CallerInfo(1)

	return mmBeginFunc
}

// Inspect accepts an inspector function that has same arguments as the Tx.BeginFunc
func (mmBeginFunc *mTXMockBeginFunc) Inspect(f func(ctx context.Context, f func(mm_pgx.Tx) error)) *mTXMockBeginFunc {
	if mmBeginFunc.mock.inspectFuncBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("Inspect function is already set for TXMock.BeginFunc")
	}

	mmBeginFunc.mock.inspectFuncBeginFunc = f

	return mmBeginFunc
}

// Return sets up results that will be returned by Tx.BeginFunc
func (mmBeginFunc *mTXMockBeginFunc) Return(err error) *TXMock {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TXMockBeginFuncExpectation{mock: mmBeginFunc.mock}
	}
	mmBeginFunc.defaultExpectation.results = &TXMockBeginFuncResults{err}
	mmBeginFunc.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBeginFunc.mock
}

// Set uses given function f to mock the Tx.BeginFunc method
func (mmBeginFunc *mTXMockBeginFunc) Set(f func(ctx context.Context, f func(mm_pgx.Tx) error) (err error)) *TXMock {
	if mmBeginFunc.defaultExpectation != nil {
		mmBeginFunc.mock.t.Fatalf("Default expectation is already set for the Tx.BeginFunc method")
	}

	if len(mmBeginFunc.expectations) > 0 {
		mmBeginFunc.mock.t.Fatalf("Some expectations are already set for the Tx.BeginFunc method")
	}

	mmBeginFunc.mock.funcBeginFunc = f
	mmBeginFunc.mock.funcBeginFuncOrigin = minimock.CallerInfo(1)
	return mmBeginFunc.mock
}

// When sets expectation for the Tx.BeginFunc which will trigger the result defined by the following
// Then helper
func (mmBeginFunc *mTXMockBeginFunc) When(ctx context.Context, f func(mm_pgx.Tx) error) *TXMockBeginFuncExpectation {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TXMock.BeginFunc mock is already set by Set")
	}

	expectation := &TXMockBeginFuncExpectation{
		mock:               mmBeginFunc.mock,
		params:             &TXMockBeginFuncParams{ctx, f},
		expectationOrigins: TXMockBeginFuncExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBeginFunc.expectations = append(mmBeginFunc.expectations, expectation)
	return expectation
}

// Then sets up Tx.BeginFunc return parameters for the expectation previously defined by the When method
func (e *TXMockBeginFuncExpectation) Then(err error) *TXMock {
	e.results = &TXMockBeginFuncResults{err}
	return e.mock
}

// Times sets number of times Tx.BeginFunc should be invoked
func (mmBeginFunc *mTXMockBeginFunc) Times(n uint64) *mTXMockBeginFunc {
	if n == 0 {
		mmBeginFunc.mock.t.Fatalf("Times of TXMock.BeginFunc mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBeginFunc.expectedInvocations, n)
	mmBeginFunc.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBeginFunc
}

func (mmBeginFunc *mTXMockBeginFunc) invocationsDone() bool {
	if len(mmBeginFunc.expectations) == 0 && mmBeginFunc.defaultExpectation == nil && mmBeginFunc.mock.funcBeginFunc == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBeginFunc.mock.afterBeginFuncCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBeginFunc.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BeginFunc implements mm_pgx.Tx
func (mmBeginFunc *TXMock) BeginFunc(ctx context.Context, f func(mm_pgx.Tx) error) (err error) {
	mm_atomic.AddUint64(&mmBeginFunc.beforeBeginFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginFunc.afterBeginFuncCounter, 1)

	mmBeginFunc.t.Helper()

	if mmBeginFunc.inspectFuncBeginFunc != nil {
		mmBeginFunc.inspectFuncBeginFunc(ctx, f)
	}

	mm_params := TXMockBeginFuncParams{ctx, f}

	// Record call args
	mmBeginFunc.BeginFuncMock.mutex.Lock()
	mmBeginFunc.BeginFuncMock.callArgs = append(mmBeginFunc.BeginFuncMock.callArgs, &mm_params)
	mmBeginFunc.BeginFuncMock.mutex.Unlock()

	for _, e := range mmBeginFunc.BeginFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBeginFunc.BeginFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginFunc.BeginFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginFunc.BeginFuncMock.defaultExpectation.params
		mm_want_ptrs := mmBeginFunc.BeginFuncMock.defaultExpectation.paramPtrs

		mm_got := TXMockBeginFuncParams{ctx, f}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBeginFunc.t.Errorf("TXMock.BeginFunc got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBeginFunc.BeginFuncMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.f != nil && !minimock.Equal(*mm_want_ptrs.f, mm_got.f) {
				mmBeginFunc.t.Errorf("TXMock.BeginFunc got unexpected parameter f, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBeginFunc.BeginFuncMock.defaultExpectation.expectationOrigins.originF, *mm_want_ptrs.f, mm_got.f, minimock.Diff(*mm_want_ptrs.f, mm_got.f))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginFunc.t.Errorf("TXMock.BeginFunc got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBeginFunc.BeginFuncMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginFunc.BeginFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginFunc.t.Fatal("No results are set for the TXMock.BeginFunc")
		}
		return (*mm_results).err
	}
	if mmBeginFunc.funcBeginFunc != nil {
		return mmBeginFunc.funcBeginFunc(ctx, f)
	}
	mmBeginFunc.t.Fatalf("Unexpected call to TXMock.BeginFunc. %v %v", ctx, f)
	return
}

// BeginFuncAfterCounter returns a count of finished TXMock.BeginFunc invocations
func (mmBeginFunc *TXMock) BeginFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.afterBeginFuncCounter)
}

// BeginFuncBeforeCounter returns a count of TXMock.BeginFunc invocations
func (mmBeginFunc *TXMock) BeginFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.beforeBeginFuncCounter)
}

// Calls returns a list of arguments used in each call to TXMock.BeginFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginFunc *mTXMockBeginFunc) Calls() []*TXMockBeginFuncParams {
	mmBeginFunc.mutex.RLock()

	argCopy := make([]*TXMockBeginFuncParams, len(mmBeginFunc.callArgs))
	copy(argCopy, mmBeginFunc.callArgs)

	mmBeginFunc.mutex.RUnlock()

	return argCopy
}

// MinimockBeginFuncDone returns true if the count of the BeginFunc invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockBeginFuncDone() bool {
	if m.BeginFuncMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginFuncMock.invocationsDone()
}

// MinimockBeginFuncInspect logs each unmet expectation
func (m *TXMock) MinimockBeginFuncInspect() {
	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.BeginFunc at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBeginFuncCounter := mm_atomic.LoadUint64(&m.afterBeginFuncCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginFuncMock.defaultExpectation != nil && afterBeginFuncCounter < 1 {
		if m.BeginFuncMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.BeginFunc at\n%s", m.BeginFuncMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.BeginFunc at\n%s with params: %#v", m.BeginFuncMock.defaultExpectation.expectationOrigins.origin, *m.BeginFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginFunc != nil && afterBeginFuncCounter < 1 {
		m.t.Errorf("Expected call to TXMock.BeginFunc at\n%s", m.funcBeginFuncOrigin)
	}

	if !m.BeginFuncMock.invocationsDone() && afterBeginFuncCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.BeginFunc at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginFuncMock.expectedInvocations), m.BeginFuncMock.expectedInvocationsOrigin, afterBeginFuncCounter)
	}
}

type mTXMockCommit struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockCommitExpectation
	expectations       []*TXMockCommitExpectation

	callArgs []*TXMockCommitParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockCommitExpectation specifies expectation struct of the Tx.Commit
type TXMockCommitExpectation struct {
	mock               *TXMock
	params             *TXMockCommitParams
	paramPtrs          *TXMockCommitParamPtrs
	expectationOrigins TXMockCommitExpectationOrigins
	results            *TXMockCommitResults
	returnOrigin       string
	Counter            uint64
}

// TXMockCommitParams contains parameters of the Tx.Commit
type TXMockCommitParams struct {
	ctx context.Context
}

// TXMockCommitParamPtrs contains pointers to parameters of the Tx.Commit
type TXMockCommitParamPtrs struct {
	ctx *context.Context
}

// TXMockCommitResults contains results of the Tx.Commit
type TXMockCommitResults struct {
	err error
}

// TXMockCommitOrigins contains origins of expectations of the Tx.Commit
type TXMockCommitExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mTXMockCommit) Optional() *mTXMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for Tx.Commit
func (mmCommit *mTXMockCommit) Expect(ctx context.Context) *mTXMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TXMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TXMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.paramPtrs != nil {
		mmCommit.mock.t.Fatalf("TXMock.Commit mock is already set by ExpectParams functions")
	}

	mmCommit.defaultExpectation.params = &TXMockCommitParams{ctx}
	mmCommit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Commit
func (mmCommit *mTXMockCommit) ExpectCtxParam1(ctx context.Context) *mTXMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TXMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TXMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.params != nil {
		mmCommit.mock.t.Fatalf("TXMock.Commit mock is already set by Expect")
	}

	if mmCommit.defaultExpectation.paramPtrs == nil {
		mmCommit.defaultExpectation.paramPtrs = &TXMockCommitParamPtrs{}
	}
	mmCommit.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Tx.Commit
func (mmCommit *mTXMockCommit) Inspect(f func(ctx context.Context)) *mTXMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TXMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Tx.Commit
func (mmCommit *mTXMockCommit) Return(err error) *TXMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TXMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TXMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TXMockCommitResults{err}
	mmCommit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Set uses given function f to mock the Tx.Commit method
func (mmCommit *mTXMockCommit) Set(f func(ctx context.Context) (err error)) *TXMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Tx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Tx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	mmCommit.mock.funcCommitOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// When sets expectation for the Tx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mTXMockCommit) When(ctx context.Context) *TXMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TXMock.Commit mock is already set by Set")
	}

	expectation := &TXMockCommitExpectation{
		mock:               mmCommit.mock,
		params:             &TXMockCommitParams{ctx},
		expectationOrigins: TXMockCommitExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up Tx.Commit return parameters for the expectation previously defined by the When method
func (e *TXMockCommitExpectation) Then(err error) *TXMock {
	e.results = &TXMockCommitResults{err}
	return e.mock
}

// Times sets number of times Tx.Commit should be invoked
func (mmCommit *mTXMockCommit) Times(n uint64) *mTXMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of TXMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	mmCommit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommit
}

func (mmCommit *mTXMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements mm_pgx.Tx
func (mmCommit *TXMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	mmCommit.t.Helper()

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := TXMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, &mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_want_ptrs := mmCommit.CommitMock.defaultExpectation.paramPtrs

		mm_got := TXMockCommitParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommit.t.Errorf("TXMock.Commit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommit.CommitMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("TXMock.Commit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommit.CommitMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TXMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to TXMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished TXMock.Commit invocations
func (mmCommit *TXMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TXMock.Commit invocations
func (mmCommit *TXMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to TXMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mTXMockCommit) Calls() []*TXMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*TXMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *TXMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.Commit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.Commit at\n%s", m.CommitMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.Commit at\n%s with params: %#v", m.CommitMock.defaultExpectation.expectationOrigins.origin, *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Commit at\n%s", m.funcCommitOrigin)
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Commit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), m.CommitMock.expectedInvocationsOrigin, afterCommitCounter)
	}
}

type mTXMockConn struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockConnExpectation
	expectations       []*TXMockConnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockConnExpectation specifies expectation struct of the Tx.Conn
type TXMockConnExpectation struct {
	mock *TXMock

	results      *TXMockConnResults
	returnOrigin string
	Counter      uint64
}

// TXMockConnResults contains results of the Tx.Conn
type TXMockConnResults struct {
	cp1 *mm_pgx.Conn
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConn *mTXMockConn) Optional() *mTXMockConn {
	mmConn.optional = true
	return mmConn
}

// Expect sets up expected params for Tx.Conn
func (mmConn *mTXMockConn) Expect() *mTXMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TXMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TXMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the Tx.Conn
func (mmConn *mTXMockConn) Inspect(f func()) *mTXMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for TXMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by Tx.Conn
func (mmConn *mTXMockConn) Return(cp1 *mm_pgx.Conn) *TXMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TXMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TXMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &TXMockConnResults{cp1}
	mmConn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConn.mock
}

// Set uses given function f to mock the Tx.Conn method
func (mmConn *mTXMockConn) Set(f func() (cp1 *mm_pgx.Conn)) *TXMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the Tx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the Tx.Conn method")
	}

	mmConn.mock.funcConn = f
	mmConn.mock.funcConnOrigin = minimock.CallerInfo(1)
	return mmConn.mock
}

// Times sets number of times Tx.Conn should be invoked
func (mmConn *mTXMockConn) Times(n uint64) *mTXMockConn {
	if n == 0 {
		mmConn.mock.t.Fatalf("Times of TXMock.Conn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConn.expectedInvocations, n)
	mmConn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConn
}

func (mmConn *mTXMockConn) invocationsDone() bool {
	if len(mmConn.expectations) == 0 && mmConn.defaultExpectation == nil && mmConn.mock.funcConn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConn.mock.afterConnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Conn implements mm_pgx.Tx
func (mmConn *TXMock) Conn() (cp1 *mm_pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	mmConn.t.Helper()

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the TXMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to TXMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished TXMock.Conn invocations
func (mmConn *TXMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of TXMock.Conn invocations
func (mmConn *TXMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockConnDone() bool {
	if m.ConnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnMock.invocationsDone()
}

// MinimockConnInspect logs each unmet expectation
func (m *TXMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TXMock.Conn")
		}
	}

	afterConnCounter := mm_atomic.LoadUint64(&m.afterConnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && afterConnCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Conn at\n%s", m.ConnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && afterConnCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Conn at\n%s", m.funcConnOrigin)
	}

	if !m.ConnMock.invocationsDone() && afterConnCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Conn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnMock.expectedInvocations), m.ConnMock.expectedInvocationsOrigin, afterConnCounter)
	}
}

type mTXMockCopyFrom struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockCopyFromExpectation
	expectations       []*TXMockCopyFromExpectation

	callArgs []*TXMockCopyFromParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockCopyFromExpectation specifies expectation struct of the Tx.CopyFrom
type TXMockCopyFromExpectation struct {
	mock               *TXMock
	params             *TXMockCopyFromParams
	paramPtrs          *TXMockCopyFromParamPtrs
	expectationOrigins TXMockCopyFromExpectationOrigins
	results            *TXMockCopyFromResults
	returnOrigin       string
	Counter            uint64
}

// TXMockCopyFromParams contains parameters of the Tx.CopyFrom
type TXMockCopyFromParams struct {
	ctx         context.Context
	tableName   mm_pgx.Identifier
	columnNames []string
	rowSrc      mm_pgx.CopyFromSource
}

// TXMockCopyFromParamPtrs contains pointers to parameters of the Tx.CopyFrom
type TXMockCopyFromParamPtrs struct {
	ctx         *context.Context
	tableName   *mm_pgx.Identifier
	columnNames *[]string
	rowSrc      *mm_pgx.CopyFromSource
}

// TXMockCopyFromResults contains results of the Tx.CopyFrom
type TXMockCopyFromResults struct {
	i1  int64
	err error
}

// TXMockCopyFromOrigins contains origins of expectations of the Tx.CopyFrom
type TXMockCopyFromExpectationOrigins struct {
	origin            string
	originCtx         string
	originTableName   string
	originColumnNames string
	originRowSrc      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCopyFrom *mTXMockCopyFrom) Optional() *mTXMockCopyFrom {
	mmCopyFrom.optional = true
	return mmCopyFrom
}

// Expect sets up expected params for Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) Expect(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *mTXMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TXMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.paramPtrs != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by ExpectParams functions")
	}

	mmCopyFrom.defaultExpectation.params = &TXMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	mmCopyFrom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// ExpectCtxParam1 sets up expected param ctx for Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) ExpectCtxParam1(ctx context.Context) *mTXMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TXMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TXMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.ctx = &ctx
	mmCopyFrom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectTableNameParam2 sets up expected param tableName for Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) ExpectTableNameParam2(tableName mm_pgx.Identifier) *mTXMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TXMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TXMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.tableName = &tableName
	mmCopyFrom.defaultExpectation.expectationOrigins.originTableName = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectColumnNamesParam3 sets up expected param columnNames for Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) ExpectColumnNamesParam3(columnNames []string) *mTXMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TXMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TXMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.columnNames = &columnNames
	mmCopyFrom.defaultExpectation.expectationOrigins.originColumnNames = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectRowSrcParam4 sets up expected param rowSrc for Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) ExpectRowSrcParam4(rowSrc mm_pgx.CopyFromSource) *mTXMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TXMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TXMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.rowSrc = &rowSrc
	mmCopyFrom.defaultExpectation.expectationOrigins.originRowSrc = minimock.CallerInfo(1)

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) Inspect(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)) *mTXMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for TXMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by Tx.CopyFrom
func (mmCopyFrom *mTXMockCopyFrom) Return(i1 int64, err error) *TXMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TXMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &TXMockCopyFromResults{i1, err}
	mmCopyFrom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCopyFrom.mock
}

// Set uses given function f to mock the Tx.CopyFrom method
func (mmCopyFrom *mTXMockCopyFrom) Set(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)) *TXMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the Tx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the Tx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	mmCopyFrom.mock.funcCopyFromOrigin = minimock.CallerInfo(1)
	return mmCopyFrom.mock
}

// When sets expectation for the Tx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mTXMockCopyFrom) When(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *TXMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TXMock.CopyFrom mock is already set by Set")
	}

	expectation := &TXMockCopyFromExpectation{
		mock:               mmCopyFrom.mock,
		params:             &TXMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
		expectationOrigins: TXMockCopyFromExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up Tx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *TXMockCopyFromExpectation) Then(i1 int64, err error) *TXMock {
	e.results = &TXMockCopyFromResults{i1, err}
	return e.mock
}

// Times sets number of times Tx.CopyFrom should be invoked
func (mmCopyFrom *mTXMockCopyFrom) Times(n uint64) *mTXMockCopyFrom {
	if n == 0 {
		mmCopyFrom.mock.t.Fatalf("Times of TXMock.CopyFrom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCopyFrom.expectedInvocations, n)
	mmCopyFrom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCopyFrom
}

func (mmCopyFrom *mTXMockCopyFrom) invocationsDone() bool {
	if len(mmCopyFrom.expectations) == 0 && mmCopyFrom.defaultExpectation == nil && mmCopyFrom.mock.funcCopyFrom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCopyFrom.mock.afterCopyFromCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCopyFrom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CopyFrom implements mm_pgx.Tx
func (mmCopyFrom *TXMock) CopyFrom(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	mmCopyFrom.t.Helper()

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := TXMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, &mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_want_ptrs := mmCopyFrom.CopyFromMock.defaultExpectation.paramPtrs

		mm_got := TXMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCopyFrom.t.Errorf("TXMock.CopyFrom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmCopyFrom.t.Errorf("TXMock.CopyFrom got unexpected parameter tableName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originTableName, *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.columnNames != nil && !minimock.Equal(*mm_want_ptrs.columnNames, mm_got.columnNames) {
				mmCopyFrom.t.Errorf("TXMock.CopyFrom got unexpected parameter columnNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originColumnNames, *mm_want_ptrs.columnNames, mm_got.columnNames, minimock.Diff(*mm_want_ptrs.columnNames, mm_got.columnNames))
			}

			if mm_want_ptrs.rowSrc != nil && !minimock.Equal(*mm_want_ptrs.rowSrc, mm_got.rowSrc) {
				mmCopyFrom.t.Errorf("TXMock.CopyFrom got unexpected parameter rowSrc, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originRowSrc, *mm_want_ptrs.rowSrc, mm_got.rowSrc, minimock.Diff(*mm_want_ptrs.rowSrc, mm_got.rowSrc))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("TXMock.CopyFrom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the TXMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to TXMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished TXMock.CopyFrom invocations
func (mmCopyFrom *TXMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of TXMock.CopyFrom invocations
func (mmCopyFrom *TXMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to TXMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mTXMockCopyFrom) Calls() []*TXMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*TXMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockCopyFromDone() bool {
	if m.CopyFromMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CopyFromMock.invocationsDone()
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *TXMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.CopyFrom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCopyFromCounter := mm_atomic.LoadUint64(&m.afterCopyFromCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && afterCopyFromCounter < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.CopyFrom at\n%s", m.CopyFromMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.CopyFrom at\n%s with params: %#v", m.CopyFromMock.defaultExpectation.expectationOrigins.origin, *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && afterCopyFromCounter < 1 {
		m.t.Errorf("Expected call to TXMock.CopyFrom at\n%s", m.funcCopyFromOrigin)
	}

	if !m.CopyFromMock.invocationsDone() && afterCopyFromCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.CopyFrom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CopyFromMock.expectedInvocations), m.CopyFromMock.expectedInvocationsOrigin, afterCopyFromCounter)
	}
}

type mTXMockExec struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockExecExpectation
	expectations       []*TXMockExecExpectation

	callArgs []*TXMockExecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockExecExpectation specifies expectation struct of the Tx.Exec
type TXMockExecExpectation struct {
	mock               *TXMock
	params             *TXMockExecParams
	paramPtrs          *TXMockExecParamPtrs
	expectationOrigins TXMockExecExpectationOrigins
	results            *TXMockExecResults
	returnOrigin       string
	Counter            uint64
}

// TXMockExecParams contains parameters of the Tx.Exec
type TXMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []interface{}
}

// TXMockExecParamPtrs contains pointers to parameters of the Tx.Exec
type TXMockExecParamPtrs struct {
	ctx       *context.Context
	sql       *string
	arguments *[]interface{}
}

// TXMockExecResults contains results of the Tx.Exec
type TXMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// TXMockExecOrigins contains origins of expectations of the Tx.Exec
type TXMockExecExpectationOrigins struct {
	origin          string
	originCtx       string
	originSql       string
	originArguments string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mTXMockExec) Optional() *mTXMockExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for Tx.Exec
func (mmExec *mTXMockExec) Expect(ctx context.Context, sql string, arguments ...interface{}) *mTXMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TXMockExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &TXMockExecParams{ctx, sql, arguments}
	mmExec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Exec
func (mmExec *mTXMockExec) ExpectCtxParam1(ctx context.Context) *mTXMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TXMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TXMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx
	mmExec.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExec
}

// ExpectSqlParam2 sets up expected param sql for Tx.Exec
func (mmExec *mTXMockExec) ExpectSqlParam2(sql string) *mTXMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TXMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TXMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.sql = &sql
	mmExec.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmExec
}

// ExpectArgumentsParam3 sets up expected param arguments for Tx.Exec
func (mmExec *mTXMockExec) ExpectArgumentsParam3(arguments ...interface{}) *mTXMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TXMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TXMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.arguments = &arguments
	mmExec.defaultExpectation.expectationOrigins.originArguments = minimock.CallerInfo(1)

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Tx.Exec
func (mmExec *mTXMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...interface{})) *mTXMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for TXMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Tx.Exec
func (mmExec *mTXMockExec) Return(commandTag pgconn.CommandTag, err error) *TXMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TXMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &TXMockExecResults{commandTag, err}
	mmExec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// Set uses given function f to mock the Tx.Exec method
func (mmExec *mTXMockExec) Set(f func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)) *TXMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Tx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Tx.Exec method")
	}

	mmExec.mock.funcExec = f
	mmExec.mock.funcExecOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// When sets expectation for the Tx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mTXMockExec) When(ctx context.Context, sql string, arguments ...interface{}) *TXMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TXMock.Exec mock is already set by Set")
	}

	expectation := &TXMockExecExpectation{
		mock:               mmExec.mock,
		params:             &TXMockExecParams{ctx, sql, arguments},
		expectationOrigins: TXMockExecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Tx.Exec return parameters for the expectation previously defined by the When method
func (e *TXMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *TXMock {
	e.results = &TXMockExecResults{commandTag, err}
	return e.mock
}

// Times sets number of times Tx.Exec should be invoked
func (mmExec *mTXMockExec) Times(n uint64) *mTXMockExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of TXMock.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	mmExec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExec
}

func (mmExec *mTXMockExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements mm_pgx.Tx
func (mmExec *TXMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	mmExec.t.Helper()

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := TXMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := TXMockExecParams{ctx, sql, arguments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("TXMock.Exec got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmExec.t.Errorf("TXMock.Exec got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.arguments != nil && !minimock.Equal(*mm_want_ptrs.arguments, mm_got.arguments) {
				mmExec.t.Errorf("TXMock.Exec got unexpected parameter arguments, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originArguments, *mm_want_ptrs.arguments, mm_got.arguments, minimock.Diff(*mm_want_ptrs.arguments, mm_got.arguments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("TXMock.Exec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExec.ExecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the TXMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to TXMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished TXMock.Exec invocations
func (mmExec *TXMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of TXMock.Exec invocations
func (mmExec *TXMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to TXMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mTXMockExec) Calls() []*TXMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*TXMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *TXMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.Exec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.Exec at\n%s", m.ExecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.Exec at\n%s with params: %#v", m.ExecMock.defaultExpectation.expectationOrigins.origin, *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Exec at\n%s", m.funcExecOrigin)
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Exec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), m.ExecMock.expectedInvocationsOrigin, afterExecCounter)
	}
}

type mTXMockLargeObjects struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockLargeObjectsExpectation
	expectations       []*TXMockLargeObjectsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockLargeObjectsExpectation specifies expectation struct of the Tx.LargeObjects
type TXMockLargeObjectsExpectation struct {
	mock *TXMock

	results      *TXMockLargeObjectsResults
	returnOrigin string
	Counter      uint64
}

// TXMockLargeObjectsResults contains results of the Tx.LargeObjects
type TXMockLargeObjectsResults struct {
	l1 mm_pgx.LargeObjects
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLargeObjects *mTXMockLargeObjects) Optional() *mTXMockLargeObjects {
	mmLargeObjects.optional = true
	return mmLargeObjects
}

// Expect sets up expected params for Tx.LargeObjects
func (mmLargeObjects *mTXMockLargeObjects) Expect() *mTXMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TXMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TXMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the Tx.LargeObjects
func (mmLargeObjects *mTXMockLargeObjects) Inspect(f func()) *mTXMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for TXMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by Tx.LargeObjects
func (mmLargeObjects *mTXMockLargeObjects) Return(l1 mm_pgx.LargeObjects) *TXMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TXMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TXMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &TXMockLargeObjectsResults{l1}
	mmLargeObjects.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLargeObjects.mock
}

// Set uses given function f to mock the Tx.LargeObjects method
func (mmLargeObjects *mTXMockLargeObjects) Set(f func() (l1 mm_pgx.LargeObjects)) *TXMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the Tx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the Tx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	mmLargeObjects.mock.funcLargeObjectsOrigin = minimock.CallerInfo(1)
	return mmLargeObjects.mock
}

// Times sets number of times Tx.LargeObjects should be invoked
func (mmLargeObjects *mTXMockLargeObjects) Times(n uint64) *mTXMockLargeObjects {
	if n == 0 {
		mmLargeObjects.mock.t.Fatalf("Times of TXMock.LargeObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLargeObjects.expectedInvocations, n)
	mmLargeObjects.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLargeObjects
}

func (mmLargeObjects *mTXMockLargeObjects) invocationsDone() bool {
	if len(mmLargeObjects.expectations) == 0 && mmLargeObjects.defaultExpectation == nil && mmLargeObjects.mock.funcLargeObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLargeObjects.mock.afterLargeObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLargeObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LargeObjects implements mm_pgx.Tx
func (mmLargeObjects *TXMock) LargeObjects() (l1 mm_pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	mmLargeObjects.t.Helper()

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the TXMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to TXMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished TXMock.LargeObjects invocations
func (mmLargeObjects *TXMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of TXMock.LargeObjects invocations
func (mmLargeObjects *TXMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockLargeObjectsDone() bool {
	if m.LargeObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LargeObjectsMock.invocationsDone()
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *TXMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TXMock.LargeObjects")
		}
	}

	afterLargeObjectsCounter := mm_atomic.LoadUint64(&m.afterLargeObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && afterLargeObjectsCounter < 1 {
		m.t.Errorf("Expected call to TXMock.LargeObjects at\n%s", m.LargeObjectsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && afterLargeObjectsCounter < 1 {
		m.t.Errorf("Expected call to TXMock.LargeObjects at\n%s", m.funcLargeObjectsOrigin)
	}

	if !m.LargeObjectsMock.invocationsDone() && afterLargeObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.LargeObjects at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LargeObjectsMock.expectedInvocations), m.LargeObjectsMock.expectedInvocationsOrigin, afterLargeObjectsCounter)
	}
}

type mTXMockPrepare struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockPrepareExpectation
	expectations       []*TXMockPrepareExpectation

	callArgs []*TXMockPrepareParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockPrepareExpectation specifies expectation struct of the Tx.Prepare
type TXMockPrepareExpectation struct {
	mock               *TXMock
	params             *TXMockPrepareParams
	paramPtrs          *TXMockPrepareParamPtrs
	expectationOrigins TXMockPrepareExpectationOrigins
	results            *TXMockPrepareResults
	returnOrigin       string
	Counter            uint64
}

// TXMockPrepareParams contains parameters of the Tx.Prepare
type TXMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// TXMockPrepareParamPtrs contains pointers to parameters of the Tx.Prepare
type TXMockPrepareParamPtrs struct {
	ctx  *context.Context
	name *string
	sql  *string
}

// TXMockPrepareResults contains results of the Tx.Prepare
type TXMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// TXMockPrepareOrigins contains origins of expectations of the Tx.Prepare
type TXMockPrepareExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
	originSql  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrepare *mTXMockPrepare) Optional() *mTXMockPrepare {
	mmPrepare.optional = true
	return mmPrepare
}

// Expect sets up expected params for Tx.Prepare
func (mmPrepare *mTXMockPrepare) Expect(ctx context.Context, name string, sql string) *mTXMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TXMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.paramPtrs != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by ExpectParams functions")
	}

	mmPrepare.defaultExpectation.params = &TXMockPrepareParams{ctx, name, sql}
	mmPrepare.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Prepare
func (mmPrepare *mTXMockPrepare) ExpectCtxParam1(ctx context.Context) *mTXMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TXMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TXMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.ctx = &ctx
	mmPrepare.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPrepare
}

// ExpectNameParam2 sets up expected param name for Tx.Prepare
func (mmPrepare *mTXMockPrepare) ExpectNameParam2(name string) *mTXMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TXMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TXMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.name = &name
	mmPrepare.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmPrepare
}

// ExpectSqlParam3 sets up expected param sql for Tx.Prepare
func (mmPrepare *mTXMockPrepare) ExpectSqlParam3(sql string) *mTXMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TXMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TXMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.sql = &sql
	mmPrepare.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the Tx.Prepare
func (mmPrepare *mTXMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mTXMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for TXMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by Tx.Prepare
func (mmPrepare *mTXMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *TXMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TXMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &TXMockPrepareResults{sp1, err}
	mmPrepare.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrepare.mock
}

// Set uses given function f to mock the Tx.Prepare method
func (mmPrepare *mTXMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *TXMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the Tx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the Tx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	mmPrepare.mock.funcPrepareOrigin = minimock.CallerInfo(1)
	return mmPrepare.mock
}

// When sets expectation for the Tx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mTXMockPrepare) When(ctx context.Context, name string, sql string) *TXMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TXMock.Prepare mock is already set by Set")
	}

	expectation := &TXMockPrepareExpectation{
		mock:               mmPrepare.mock,
		params:             &TXMockPrepareParams{ctx, name, sql},
		expectationOrigins: TXMockPrepareExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up Tx.Prepare return parameters for the expectation previously defined by the When method
func (e *TXMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *TXMock {
	e.results = &TXMockPrepareResults{sp1, err}
	return e.mock
}

// Times sets number of times Tx.Prepare should be invoked
func (mmPrepare *mTXMockPrepare) Times(n uint64) *mTXMockPrepare {
	if n == 0 {
		mmPrepare.mock.t.Fatalf("Times of TXMock.Prepare mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrepare.expectedInvocations, n)
	mmPrepare.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrepare
}

func (mmPrepare *mTXMockPrepare) invocationsDone() bool {
	if len(mmPrepare.expectations) == 0 && mmPrepare.defaultExpectation == nil && mmPrepare.mock.funcPrepare == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrepare.mock.afterPrepareCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrepare.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Prepare implements mm_pgx.Tx
func (mmPrepare *TXMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	mmPrepare.t.Helper()

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := TXMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, &mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_want_ptrs := mmPrepare.PrepareMock.defaultExpectation.paramPtrs

		mm_got := TXMockPrepareParams{ctx, name, sql}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrepare.t.Errorf("TXMock.Prepare got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmPrepare.t.Errorf("TXMock.Prepare got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmPrepare.t.Errorf("TXMock.Prepare got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("TXMock.Prepare got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the TXMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to TXMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished TXMock.Prepare invocations
func (mmPrepare *TXMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of TXMock.Prepare invocations
func (mmPrepare *TXMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to TXMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mTXMockPrepare) Calls() []*TXMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*TXMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockPrepareDone() bool {
	if m.PrepareMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrepareMock.invocationsDone()
}

// MinimockPrepareInspect logs each unmet expectation
func (m *TXMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.Prepare at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrepareCounter := mm_atomic.LoadUint64(&m.afterPrepareCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && afterPrepareCounter < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.Prepare at\n%s", m.PrepareMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.Prepare at\n%s with params: %#v", m.PrepareMock.defaultExpectation.expectationOrigins.origin, *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && afterPrepareCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Prepare at\n%s", m.funcPrepareOrigin)
	}

	if !m.PrepareMock.invocationsDone() && afterPrepareCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Prepare at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrepareMock.expectedInvocations), m.PrepareMock.expectedInvocationsOrigin, afterPrepareCounter)
	}
}

type mTXMockQuery struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockQueryExpectation
	expectations       []*TXMockQueryExpectation

	callArgs []*TXMockQueryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockQueryExpectation specifies expectation struct of the Tx.Query
type TXMockQueryExpectation struct {
	mock               *TXMock
	params             *TXMockQueryParams
	paramPtrs          *TXMockQueryParamPtrs
	expectationOrigins TXMockQueryExpectationOrigins
	results            *TXMockQueryResults
	returnOrigin       string
	Counter            uint64
}

// TXMockQueryParams contains parameters of the Tx.Query
type TXMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TXMockQueryParamPtrs contains pointers to parameters of the Tx.Query
type TXMockQueryParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]interface{}
}

// TXMockQueryResults contains results of the Tx.Query
type TXMockQueryResults struct {
	r1  mm_pgx.Rows
	err error
}

// TXMockQueryOrigins contains origins of expectations of the Tx.Query
type TXMockQueryExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuery *mTXMockQuery) Optional() *mTXMockQuery {
	mmQuery.optional = true
	return mmQuery
}

// Expect sets up expected params for Tx.Query
func (mmQuery *mTXMockQuery) Expect(ctx context.Context, sql string, args ...interface{}) *mTXMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TXMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.paramPtrs != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by ExpectParams functions")
	}

	mmQuery.defaultExpectation.params = &TXMockQueryParams{ctx, sql, args}
	mmQuery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Query
func (mmQuery *mTXMockQuery) ExpectCtxParam1(ctx context.Context) *mTXMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TXMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TXMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectSqlParam2 sets up expected param sql for Tx.Query
func (mmQuery *mTXMockQuery) ExpectSqlParam2(sql string) *mTXMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TXMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TXMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.sql = &sql
	mmQuery.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectArgsParam3 sets up expected param args for Tx.Query
func (mmQuery *mTXMockQuery) ExpectArgsParam3(args ...interface{}) *mTXMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TXMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TXMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.args = &args
	mmQuery.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the Tx.Query
func (mmQuery *mTXMockQuery) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTXMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for TXMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by Tx.Query
func (mmQuery *mTXMockQuery) Return(r1 mm_pgx.Rows, err error) *TXMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TXMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &TXMockQueryResults{r1, err}
	mmQuery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// Set uses given function f to mock the Tx.Query method
func (mmQuery *mTXMockQuery) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Rows, err error)) *TXMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the Tx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the Tx.Query method")
	}

	mmQuery.mock.funcQuery = f
	mmQuery.mock.funcQueryOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// When sets expectation for the Tx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mTXMockQuery) When(ctx context.Context, sql string, args ...interface{}) *TXMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TXMock.Query mock is already set by Set")
	}

	expectation := &TXMockQueryExpectation{
		mock:               mmQuery.mock,
		params:             &TXMockQueryParams{ctx, sql, args},
		expectationOrigins: TXMockQueryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up Tx.Query return parameters for the expectation previously defined by the When method
func (e *TXMockQueryExpectation) Then(r1 mm_pgx.Rows, err error) *TXMock {
	e.results = &TXMockQueryResults{r1, err}
	return e.mock
}

// Times sets number of times Tx.Query should be invoked
func (mmQuery *mTXMockQuery) Times(n uint64) *mTXMockQuery {
	if n == 0 {
		mmQuery.mock.t.Fatalf("Times of TXMock.Query mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuery.expectedInvocations, n)
	mmQuery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuery
}

func (mmQuery *mTXMockQuery) invocationsDone() bool {
	if len(mmQuery.expectations) == 0 && mmQuery.defaultExpectation == nil && mmQuery.mock.funcQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuery.mock.afterQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Query implements mm_pgx.Tx
func (mmQuery *TXMock) Query(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	mmQuery.t.Helper()

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := TXMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_want_ptrs := mmQuery.QueryMock.defaultExpectation.paramPtrs

		mm_got := TXMockQueryParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuery.t.Errorf("TXMock.Query got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQuery.t.Errorf("TXMock.Query got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQuery.t.Errorf("TXMock.Query got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("TXMock.Query got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuery.QueryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the TXMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to TXMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished TXMock.Query invocations
func (mmQuery *TXMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of TXMock.Query invocations
func (mmQuery *TXMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to TXMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mTXMockQuery) Calls() []*TXMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*TXMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockQueryDone() bool {
	if m.QueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryMock.invocationsDone()
}

// MinimockQueryInspect logs each unmet expectation
func (m *TXMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.Query at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryCounter := mm_atomic.LoadUint64(&m.afterQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && afterQueryCounter < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.Query at\n%s", m.QueryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.Query at\n%s with params: %#v", m.QueryMock.defaultExpectation.expectationOrigins.origin, *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && afterQueryCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Query at\n%s", m.funcQueryOrigin)
	}

	if !m.QueryMock.invocationsDone() && afterQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Query at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryMock.expectedInvocations), m.QueryMock.expectedInvocationsOrigin, afterQueryCounter)
	}
}

type mTXMockQueryFunc struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockQueryFuncExpectation
	expectations       []*TXMockQueryFuncExpectation

	callArgs []*TXMockQueryFuncParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockQueryFuncExpectation specifies expectation struct of the Tx.QueryFunc
type TXMockQueryFuncExpectation struct {
	mock               *TXMock
	params             *TXMockQueryFuncParams
	paramPtrs          *TXMockQueryFuncParamPtrs
	expectationOrigins TXMockQueryFuncExpectationOrigins
	results            *TXMockQueryFuncResults
	returnOrigin       string
	Counter            uint64
}

// TXMockQueryFuncParams contains parameters of the Tx.QueryFunc
type TXMockQueryFuncParams struct {
	ctx   context.Context
	sql   string
	args  []interface{}
	scans []interface{}
	f     func(mm_pgx.QueryFuncRow) error
}

// TXMockQueryFuncParamPtrs contains pointers to parameters of the Tx.QueryFunc
type TXMockQueryFuncParamPtrs struct {
	ctx   *context.Context
	sql   *string
	args  *[]interface{}
	scans *[]interface{}
	f     *func(mm_pgx.QueryFuncRow) error
}

// TXMockQueryFuncResults contains results of the Tx.QueryFunc
type TXMockQueryFuncResults struct {
	c2  pgconn.CommandTag
	err error
}

// TXMockQueryFuncOrigins contains origins of expectations of the Tx.QueryFunc
type TXMockQueryFuncExpectationOrigins struct {
	origin      string
	originCtx   string
	originSql   string
	originArgs  string
	originScans string
	originF     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryFunc *mTXMockQueryFunc) Optional() *mTXMockQueryFunc {
	mmQueryFunc.optional = true
	return mmQueryFunc
}

// Expect sets up expected params for Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) Expect(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) *mTXMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.paramPtrs != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by ExpectParams functions")
	}

	mmQueryFunc.defaultExpectation.params = &TXMockQueryFuncParams{ctx, sql, args, scans, f}
	mmQueryFunc.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryFunc.expectations {
		if minimock.Equal(e.params, mmQueryFunc.defaultExpectation.params) {
			mmQueryFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryFunc.defaultExpectation.params)
		}
	}

	return mmQueryFunc
}

// ExpectCtxParam1 sets up expected param ctx for Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) ExpectCtxParam1(ctx context.Context) *mTXMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TXMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryFunc.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryFunc
}

// ExpectSqlParam2 sets up expected param sql for Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) ExpectSqlParam2(sql string) *mTXMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TXMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.sql = &sql
	mmQueryFunc.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQueryFunc
}

// ExpectArgsParam3 sets up expected param args for Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) ExpectArgsParam3(args []interface{}) *mTXMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TXMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.args = &args
	mmQueryFunc.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryFunc
}

// ExpectScansParam4 sets up expected param scans for Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) ExpectScansParam4(scans []interface{}) *mTXMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TXMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.scans = &scans
	mmQueryFunc.defaultExpectation.expectationOrigins.originScans = minimock.CallerInfo(1)

	return mmQueryFunc
}

// ExpectFParam5 sets up expected param f for Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) ExpectFParam5(f func(mm_pgx.QueryFuncRow) error) *mTXMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{}
	}

	if mmQueryFunc.defaultExpectation.params != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Expect")
	}

	if mmQueryFunc.defaultExpectation.paramPtrs == nil {
		mmQueryFunc.defaultExpectation.paramPtrs = &TXMockQueryFuncParamPtrs{}
	}
	mmQueryFunc.defaultExpectation.paramPtrs.f = &f
	mmQueryFunc.defaultExpectation.expectationOrigins.originF = minimock.CallerInfo(1)

	return mmQueryFunc
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) Inspect(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error)) *mTXMockQueryFunc {
	if mmQueryFunc.mock.inspectFuncQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("Inspect function is already set for TXMock.QueryFunc")
	}

	mmQueryFunc.mock.inspectFuncQueryFunc = f

	return mmQueryFunc
}

// Return sets up results that will be returned by Tx.QueryFunc
func (mmQueryFunc *mTXMockQueryFunc) Return(c2 pgconn.CommandTag, err error) *TXMock {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TXMockQueryFuncExpectation{mock: mmQueryFunc.mock}
	}
	mmQueryFunc.defaultExpectation.results = &TXMockQueryFuncResults{c2, err}
	mmQueryFunc.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryFunc.mock
}

// Set uses given function f to mock the Tx.QueryFunc method
func (mmQueryFunc *mTXMockQueryFunc) Set(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)) *TXMock {
	if mmQueryFunc.defaultExpectation != nil {
		mmQueryFunc.mock.t.Fatalf("Default expectation is already set for the Tx.QueryFunc method")
	}

	if len(mmQueryFunc.expectations) > 0 {
		mmQueryFunc.mock.t.Fatalf("Some expectations are already set for the Tx.QueryFunc method")
	}

	mmQueryFunc.mock.funcQueryFunc = f
	mmQueryFunc.mock.funcQueryFuncOrigin = minimock.CallerInfo(1)
	return mmQueryFunc.mock
}

// When sets expectation for the Tx.QueryFunc which will trigger the result defined by the following
// Then helper
func (mmQueryFunc *mTXMockQueryFunc) When(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) *TXMockQueryFuncExpectation {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TXMock.QueryFunc mock is already set by Set")
	}

	expectation := &TXMockQueryFuncExpectation{
		mock:               mmQueryFunc.mock,
		params:             &TXMockQueryFuncParams{ctx, sql, args, scans, f},
		expectationOrigins: TXMockQueryFuncExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryFunc.expectations = append(mmQueryFunc.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryFunc return parameters for the expectation previously defined by the When method
func (e *TXMockQueryFuncExpectation) Then(c2 pgconn.CommandTag, err error) *TXMock {
	e.results = &TXMockQueryFuncResults{c2, err}
	return e.mock
}

// Times sets number of times Tx.QueryFunc should be invoked
func (mmQueryFunc *mTXMockQueryFunc) Times(n uint64) *mTXMockQueryFunc {
	if n == 0 {
		mmQueryFunc.mock.t.Fatalf("Times of TXMock.QueryFunc mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryFunc.expectedInvocations, n)
	mmQueryFunc.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryFunc
}

func (mmQueryFunc *mTXMockQueryFunc) invocationsDone() bool {
	if len(mmQueryFunc.expectations) == 0 && mmQueryFunc.defaultExpectation == nil && mmQueryFunc.mock.funcQueryFunc == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryFunc.mock.afterQueryFuncCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryFunc.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryFunc implements mm_pgx.Tx
func (mmQueryFunc *TXMock) QueryFunc(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmQueryFunc.beforeQueryFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryFunc.afterQueryFuncCounter, 1)

	mmQueryFunc.t.Helper()

	if mmQueryFunc.inspectFuncQueryFunc != nil {
		mmQueryFunc.inspectFuncQueryFunc(ctx, sql, args, scans, f)
	}

	mm_params := TXMockQueryFuncParams{ctx, sql, args, scans, f}

	// Record call args
	mmQueryFunc.QueryFuncMock.mutex.Lock()
	mmQueryFunc.QueryFuncMock.callArgs = append(mmQueryFunc.QueryFuncMock.callArgs, &mm_params)
	mmQueryFunc.QueryFuncMock.mutex.Unlock()

	for _, e := range mmQueryFunc.QueryFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmQueryFunc.QueryFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryFunc.QueryFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryFunc.QueryFuncMock.defaultExpectation.params
		mm_want_ptrs := mmQueryFunc.QueryFuncMock.defaultExpectation.paramPtrs

		mm_got := TXMockQueryFuncParams{ctx, sql, args, scans, f}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryFunc.t.Errorf("TXMock.QueryFunc got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryFunc.QueryFuncMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryFunc.t.Errorf("TXMock.QueryFunc got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryFunc.QueryFuncMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryFunc.t.Errorf("TXMock.QueryFunc got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryFunc.QueryFuncMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

			if mm_want_ptrs.scans != nil && !minimock.Equal(*mm_want_ptrs.scans, mm_got.scans) {
				mmQueryFunc.t.Errorf("TXMock.QueryFunc got unexpected parameter scans, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryFunc.QueryFuncMock.defaultExpectation.expectationOrigins.originScans, *mm_want_ptrs.scans, mm_got.scans, minimock.Diff(*mm_want_ptrs.scans, mm_got.scans))
			}

			if mm_want_ptrs.f != nil && !minimock.Equal(*mm_want_ptrs.f, mm_got.f) {
				mmQueryFunc.t.Errorf("TXMock.QueryFunc got unexpected parameter f, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryFunc.QueryFuncMock.defaultExpectation.expectationOrigins.originF, *mm_want_ptrs.f, mm_got.f, minimock.Diff(*mm_want_ptrs.f, mm_got.f))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryFunc.t.Errorf("TXMock.QueryFunc got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryFunc.QueryFuncMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryFunc.QueryFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryFunc.t.Fatal("No results are set for the TXMock.QueryFunc")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmQueryFunc.funcQueryFunc != nil {
		return mmQueryFunc.funcQueryFunc(ctx, sql, args, scans, f)
	}
	mmQueryFunc.t.Fatalf("Unexpected call to TXMock.QueryFunc. %v %v %v %v %v", ctx, sql, args, scans, f)
	return
}

// QueryFuncAfterCounter returns a count of finished TXMock.QueryFunc invocations
func (mmQueryFunc *TXMock) QueryFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.afterQueryFuncCounter)
}

// QueryFuncBeforeCounter returns a count of TXMock.QueryFunc invocations
func (mmQueryFunc *TXMock) QueryFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.beforeQueryFuncCounter)
}

// Calls returns a list of arguments used in each call to TXMock.QueryFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryFunc *mTXMockQueryFunc) Calls() []*TXMockQueryFuncParams {
	mmQueryFunc.mutex.RLock()

	argCopy := make([]*TXMockQueryFuncParams, len(mmQueryFunc.callArgs))
	copy(argCopy, mmQueryFunc.callArgs)

	mmQueryFunc.mutex.RUnlock()

	return argCopy
}

// MinimockQueryFuncDone returns true if the count of the QueryFunc invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockQueryFuncDone() bool {
	if m.QueryFuncMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryFuncMock.invocationsDone()
}

// MinimockQueryFuncInspect logs each unmet expectation
func (m *TXMock) MinimockQueryFuncInspect() {
	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.QueryFunc at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryFuncCounter := mm_atomic.LoadUint64(&m.afterQueryFuncCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryFuncMock.defaultExpectation != nil && afterQueryFuncCounter < 1 {
		if m.QueryFuncMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.QueryFunc at\n%s", m.QueryFuncMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.QueryFunc at\n%s with params: %#v", m.QueryFuncMock.defaultExpectation.expectationOrigins.origin, *m.QueryFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryFunc != nil && afterQueryFuncCounter < 1 {
		m.t.Errorf("Expected call to TXMock.QueryFunc at\n%s", m.funcQueryFuncOrigin)
	}

	if !m.QueryFuncMock.invocationsDone() && afterQueryFuncCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.QueryFunc at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryFuncMock.expectedInvocations), m.QueryFuncMock.expectedInvocationsOrigin, afterQueryFuncCounter)
	}
}

type mTXMockQueryRow struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockQueryRowExpectation
	expectations       []*TXMockQueryRowExpectation

	callArgs []*TXMockQueryRowParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockQueryRowExpectation specifies expectation struct of the Tx.QueryRow
type TXMockQueryRowExpectation struct {
	mock               *TXMock
	params             *TXMockQueryRowParams
	paramPtrs          *TXMockQueryRowParamPtrs
	expectationOrigins TXMockQueryRowExpectationOrigins
	results            *TXMockQueryRowResults
	returnOrigin       string
	Counter            uint64
}

// TXMockQueryRowParams contains parameters of the Tx.QueryRow
type TXMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TXMockQueryRowParamPtrs contains pointers to parameters of the Tx.QueryRow
type TXMockQueryRowParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]interface{}
}

// TXMockQueryRowResults contains results of the Tx.QueryRow
type TXMockQueryRowResults struct {
	r1 mm_pgx.Row
}

// TXMockQueryRowOrigins contains origins of expectations of the Tx.QueryRow
type TXMockQueryRowExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRow *mTXMockQueryRow) Optional() *mTXMockQueryRow {
	mmQueryRow.optional = true
	return mmQueryRow
}

// Expect sets up expected params for Tx.QueryRow
func (mmQueryRow *mTXMockQueryRow) Expect(ctx context.Context, sql string, args ...interface{}) *mTXMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TXMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.paramPtrs != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by ExpectParams functions")
	}

	mmQueryRow.defaultExpectation.params = &TXMockQueryRowParams{ctx, sql, args}
	mmQueryRow.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// ExpectCtxParam1 sets up expected param ctx for Tx.QueryRow
func (mmQueryRow *mTXMockQueryRow) ExpectCtxParam1(ctx context.Context) *mTXMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TXMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TXMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryRow.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryRow
}

// ExpectSqlParam2 sets up expected param sql for Tx.QueryRow
func (mmQueryRow *mTXMockQueryRow) ExpectSqlParam2(sql string) *mTXMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TXMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TXMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.sql = &sql
	mmQueryRow.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQueryRow
}

// ExpectArgsParam3 sets up expected param args for Tx.QueryRow
func (mmQueryRow *mTXMockQueryRow) ExpectArgsParam3(args ...interface{}) *mTXMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TXMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TXMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.args = &args
	mmQueryRow.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryRow
func (mmQueryRow *mTXMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTXMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for TXMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by Tx.QueryRow
func (mmQueryRow *mTXMockQueryRow) Return(r1 mm_pgx.Row) *TXMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TXMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &TXMockQueryRowResults{r1}
	mmQueryRow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryRow.mock
}

// Set uses given function f to mock the Tx.QueryRow method
func (mmQueryRow *mTXMockQueryRow) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Row)) *TXMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the Tx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the Tx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	mmQueryRow.mock.funcQueryRowOrigin = minimock.CallerInfo(1)
	return mmQueryRow.mock
}

// When sets expectation for the Tx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mTXMockQueryRow) When(ctx context.Context, sql string, args ...interface{}) *TXMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TXMock.QueryRow mock is already set by Set")
	}

	expectation := &TXMockQueryRowExpectation{
		mock:               mmQueryRow.mock,
		params:             &TXMockQueryRowParams{ctx, sql, args},
		expectationOrigins: TXMockQueryRowExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryRow return parameters for the expectation previously defined by the When method
func (e *TXMockQueryRowExpectation) Then(r1 mm_pgx.Row) *TXMock {
	e.results = &TXMockQueryRowResults{r1}
	return e.mock
}

// Times sets number of times Tx.QueryRow should be invoked
func (mmQueryRow *mTXMockQueryRow) Times(n uint64) *mTXMockQueryRow {
	if n == 0 {
		mmQueryRow.mock.t.Fatalf("Times of TXMock.QueryRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRow.expectedInvocations, n)
	mmQueryRow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryRow
}

func (mmQueryRow *mTXMockQueryRow) invocationsDone() bool {
	if len(mmQueryRow.expectations) == 0 && mmQueryRow.defaultExpectation == nil && mmQueryRow.mock.funcQueryRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRow.mock.afterQueryRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRow implements mm_pgx.Tx
func (mmQueryRow *TXMock) QueryRow(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	mmQueryRow.t.Helper()

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := TXMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRow.QueryRowMock.defaultExpectation.paramPtrs

		mm_got := TXMockQueryRowParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRow.t.Errorf("TXMock.QueryRow got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryRow.t.Errorf("TXMock.QueryRow got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRow.t.Errorf("TXMock.QueryRow got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("TXMock.QueryRow got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the TXMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to TXMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished TXMock.QueryRow invocations
func (mmQueryRow *TXMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of TXMock.QueryRow invocations
func (mmQueryRow *TXMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to TXMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mTXMockQueryRow) Calls() []*TXMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*TXMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockQueryRowDone() bool {
	if m.QueryRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowMock.invocationsDone()
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *TXMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.QueryRow at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryRowCounter := mm_atomic.LoadUint64(&m.afterQueryRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && afterQueryRowCounter < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.QueryRow at\n%s", m.QueryRowMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.QueryRow at\n%s with params: %#v", m.QueryRowMock.defaultExpectation.expectationOrigins.origin, *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && afterQueryRowCounter < 1 {
		m.t.Errorf("Expected call to TXMock.QueryRow at\n%s", m.funcQueryRowOrigin)
	}

	if !m.QueryRowMock.invocationsDone() && afterQueryRowCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.QueryRow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowMock.expectedInvocations), m.QueryRowMock.expectedInvocationsOrigin, afterQueryRowCounter)
	}
}

type mTXMockRollback struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockRollbackExpectation
	expectations       []*TXMockRollbackExpectation

	callArgs []*TXMockRollbackParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockRollbackExpectation specifies expectation struct of the Tx.Rollback
type TXMockRollbackExpectation struct {
	mock               *TXMock
	params             *TXMockRollbackParams
	paramPtrs          *TXMockRollbackParamPtrs
	expectationOrigins TXMockRollbackExpectationOrigins
	results            *TXMockRollbackResults
	returnOrigin       string
	Counter            uint64
}

// TXMockRollbackParams contains parameters of the Tx.Rollback
type TXMockRollbackParams struct {
	ctx context.Context
}

// TXMockRollbackParamPtrs contains pointers to parameters of the Tx.Rollback
type TXMockRollbackParamPtrs struct {
	ctx *context.Context
}

// TXMockRollbackResults contains results of the Tx.Rollback
type TXMockRollbackResults struct {
	err error
}

// TXMockRollbackOrigins contains origins of expectations of the Tx.Rollback
type TXMockRollbackExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollback *mTXMockRollback) Optional() *mTXMockRollback {
	mmRollback.optional = true
	return mmRollback
}

// Expect sets up expected params for Tx.Rollback
func (mmRollback *mTXMockRollback) Expect(ctx context.Context) *mTXMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TXMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TXMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.paramPtrs != nil {
		mmRollback.mock.t.Fatalf("TXMock.Rollback mock is already set by ExpectParams functions")
	}

	mmRollback.defaultExpectation.params = &TXMockRollbackParams{ctx}
	mmRollback.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Rollback
func (mmRollback *mTXMockRollback) ExpectCtxParam1(ctx context.Context) *mTXMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TXMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TXMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.params != nil {
		mmRollback.mock.t.Fatalf("TXMock.Rollback mock is already set by Expect")
	}

	if mmRollback.defaultExpectation.paramPtrs == nil {
		mmRollback.defaultExpectation.paramPtrs = &TXMockRollbackParamPtrs{}
	}
	mmRollback.defaultExpectation.paramPtrs.ctx = &ctx
	mmRollback.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Tx.Rollback
func (mmRollback *mTXMockRollback) Inspect(f func(ctx context.Context)) *mTXMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TXMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Tx.Rollback
func (mmRollback *mTXMockRollback) Return(err error) *TXMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TXMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TXMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &TXMockRollbackResults{err}
	mmRollback.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// Set uses given function f to mock the Tx.Rollback method
func (mmRollback *mTXMockRollback) Set(f func(ctx context.Context) (err error)) *TXMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Tx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Tx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	mmRollback.mock.funcRollbackOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// When sets expectation for the Tx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mTXMockRollback) When(ctx context.Context) *TXMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TXMock.Rollback mock is already set by Set")
	}

	expectation := &TXMockRollbackExpectation{
		mock:               mmRollback.mock,
		params:             &TXMockRollbackParams{ctx},
		expectationOrigins: TXMockRollbackExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up Tx.Rollback return parameters for the expectation previously defined by the When method
func (e *TXMockRollbackExpectation) Then(err error) *TXMock {
	e.results = &TXMockRollbackResults{err}
	return e.mock
}

// Times sets number of times Tx.Rollback should be invoked
func (mmRollback *mTXMockRollback) Times(n uint64) *mTXMockRollback {
	if n == 0 {
		mmRollback.mock.t.Fatalf("Times of TXMock.Rollback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollback.expectedInvocations, n)
	mmRollback.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRollback
}

func (mmRollback *mTXMockRollback) invocationsDone() bool {
	if len(mmRollback.expectations) == 0 && mmRollback.defaultExpectation == nil && mmRollback.mock.funcRollback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollback.mock.afterRollbackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Rollback implements mm_pgx.Tx
func (mmRollback *TXMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	mmRollback.t.Helper()

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := TXMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, &mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_want_ptrs := mmRollback.RollbackMock.defaultExpectation.paramPtrs

		mm_got := TXMockRollbackParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollback.t.Errorf("TXMock.Rollback got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollback.RollbackMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("TXMock.Rollback got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRollback.RollbackMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the TXMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to TXMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished TXMock.Rollback invocations
func (mmRollback *TXMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TXMock.Rollback invocations
func (mmRollback *TXMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to TXMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mTXMockRollback) Calls() []*TXMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*TXMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockRollbackDone() bool {
	if m.RollbackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackMock.invocationsDone()
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TXMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.Rollback at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRollbackCounter := mm_atomic.LoadUint64(&m.afterRollbackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && afterRollbackCounter < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.Rollback at\n%s", m.RollbackMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.Rollback at\n%s with params: %#v", m.RollbackMock.defaultExpectation.expectationOrigins.origin, *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && afterRollbackCounter < 1 {
		m.t.Errorf("Expected call to TXMock.Rollback at\n%s", m.funcRollbackOrigin)
	}

	if !m.RollbackMock.invocationsDone() && afterRollbackCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.Rollback at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackMock.expectedInvocations), m.RollbackMock.expectedInvocationsOrigin, afterRollbackCounter)
	}
}

type mTXMockSendBatch struct {
	optional           bool
	mock               *TXMock
	defaultExpectation *TXMockSendBatchExpectation
	expectations       []*TXMockSendBatchExpectation

	callArgs []*TXMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TXMockSendBatchExpectation specifies expectation struct of the Tx.SendBatch
type TXMockSendBatchExpectation struct {
	mock               *TXMock
	params             *TXMockSendBatchParams
	paramPtrs          *TXMockSendBatchParamPtrs
	expectationOrigins TXMockSendBatchExpectationOrigins
	results            *TXMockSendBatchResults
	returnOrigin       string
	Counter            uint64
}

// TXMockSendBatchParams contains parameters of the Tx.SendBatch
type TXMockSendBatchParams struct {
	ctx context.Context
	b   *mm_pgx.Batch
}

// TXMockSendBatchParamPtrs contains pointers to parameters of the Tx.SendBatch
type TXMockSendBatchParamPtrs struct {
	ctx *context.Context
	b   **mm_pgx.Batch
}

// TXMockSendBatchResults contains results of the Tx.SendBatch
type TXMockSendBatchResults struct {
	b1 mm_pgx.BatchResults
}

// TXMockSendBatchOrigins contains origins of expectations of the Tx.SendBatch
type TXMockSendBatchExpectationOrigins struct {
	origin    string
	originCtx string
	originB   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mTXMockSendBatch) Optional() *mTXMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for Tx.SendBatch
func (mmSendBatch *mTXMockSendBatch) Expect(ctx context.Context, b *mm_pgx.Batch) *mTXMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TXMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &TXMockSendBatchParams{ctx, b}
	mmSendBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectCtxParam1 sets up expected param ctx for Tx.SendBatch
func (mmSendBatch *mTXMockSendBatch) ExpectCtxParam1(ctx context.Context) *mTXMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TXMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TXMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendBatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendBatch
}

// ExpectBParam2 sets up expected param b for Tx.SendBatch
func (mmSendBatch *mTXMockSendBatch) ExpectBParam2(b *mm_pgx.Batch) *mTXMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TXMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TXMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.b = &b
	mmSendBatch.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Tx.SendBatch
func (mmSendBatch *mTXMockSendBatch) Inspect(f func(ctx context.Context, b *mm_pgx.Batch)) *mTXMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for TXMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Tx.SendBatch
func (mmSendBatch *mTXMockSendBatch) Return(b1 mm_pgx.BatchResults) *TXMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TXMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &TXMockSendBatchResults{b1}
	mmSendBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// Set uses given function f to mock the Tx.SendBatch method
func (mmSendBatch *mTXMockSendBatch) Set(f func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)) *TXMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Tx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Tx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	mmSendBatch.mock.funcSendBatchOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// When sets expectation for the Tx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mTXMockSendBatch) When(ctx context.Context, b *mm_pgx.Batch) *TXMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TXMock.SendBatch mock is already set by Set")
	}

	expectation := &TXMockSendBatchExpectation{
		mock:               mmSendBatch.mock,
		params:             &TXMockSendBatchParams{ctx, b},
		expectationOrigins: TXMockSendBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Tx.SendBatch return parameters for the expectation previously defined by the When method
func (e *TXMockSendBatchExpectation) Then(b1 mm_pgx.BatchResults) *TXMock {
	e.results = &TXMockSendBatchResults{b1}
	return e.mock
}

// Times sets number of times Tx.SendBatch should be invoked
func (mmSendBatch *mTXMockSendBatch) Times(n uint64) *mTXMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of TXMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	mmSendBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendBatch
}

func (mmSendBatch *mTXMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements mm_pgx.Tx
func (mmSendBatch *TXMock) SendBatch(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	mmSendBatch.t.Helper()

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := TXMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := TXMockSendBatchParams{ctx, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendBatch.t.Errorf("TXMock.SendBatch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmSendBatch.t.Errorf("TXMock.SendBatch got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("TXMock.SendBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the TXMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to TXMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished TXMock.SendBatch invocations
func (mmSendBatch *TXMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of TXMock.SendBatch invocations
func (mmSendBatch *TXMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to TXMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mTXMockSendBatch) Calls() []*TXMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*TXMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *TXMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *TXMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TXMock.SendBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TXMock.SendBatch at\n%s", m.SendBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TXMock.SendBatch at\n%s with params: %#v", m.SendBatchMock.defaultExpectation.expectationOrigins.origin, *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Errorf("Expected call to TXMock.SendBatch at\n%s", m.funcSendBatchOrigin)
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to TXMock.SendBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), m.SendBatchMock.expectedInvocationsOrigin, afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TXMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockBeginFuncInspect()

			m.MinimockCommitInspect()

			m.MinimockConnInspect()

			m.MinimockCopyFromInspect()

			m.MinimockExecInspect()

			m.MinimockLargeObjectsInspect()

			m.MinimockPrepareInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryFuncInspect()

			m.MinimockQueryRowInspect()

			m.MinimockRollbackInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TXMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TXMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockBeginFuncDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryFuncDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
