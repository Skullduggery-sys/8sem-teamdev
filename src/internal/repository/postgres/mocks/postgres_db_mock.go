// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i git.iu7.bmstu.ru/vai20u117/testing/src/internal/db/postgres.DBops -o postgres_db_mock.go -n PostgresDBMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
)

// PostgresDBMock implements mm_dbpostgres.DBops
type PostgresDBMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExec          func(ctx context.Context, query string, args ...interface{}) (c2 pgconn.CommandTag, err error)
	funcExecOrigin    string
	inspectFuncExec   func(ctx context.Context, query string, args ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mPostgresDBMockExec

	funcExecQueryRow          func(ctx context.Context, query string, args ...interface{}) (r1 pgx.Row)
	funcExecQueryRowOrigin    string
	inspectFuncExecQueryRow   func(ctx context.Context, query string, args ...interface{})
	afterExecQueryRowCounter  uint64
	beforeExecQueryRowCounter uint64
	ExecQueryRowMock          mPostgresDBMockExecQueryRow

	funcGet          func(ctx context.Context, dest interface{}, query string, args ...interface{}) (err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, dest interface{}, query string, args ...interface{})
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mPostgresDBMockGet

	funcGetPool          func(ctx context.Context) (pp1 *pgxpool.Pool)
	funcGetPoolOrigin    string
	inspectFuncGetPool   func(ctx context.Context)
	afterGetPoolCounter  uint64
	beforeGetPoolCounter uint64
	GetPoolMock          mPostgresDBMockGetPool

	funcQuery          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error)
	funcQueryOrigin    string
	inspectFuncQuery   func(ctx context.Context, sql string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mPostgresDBMockQuery

	funcScanAll          func(dst interface{}, rows pgx.Rows) (err error)
	funcScanAllOrigin    string
	inspectFuncScanAll   func(dst interface{}, rows pgx.Rows)
	afterScanAllCounter  uint64
	beforeScanAllCounter uint64
	ScanAllMock          mPostgresDBMockScanAll

	funcSelect          func(ctx context.Context, dest interface{}, query string, args ...interface{}) (err error)
	funcSelectOrigin    string
	inspectFuncSelect   func(ctx context.Context, dest interface{}, query string, args ...interface{})
	afterSelectCounter  uint64
	beforeSelectCounter uint64
	SelectMock          mPostgresDBMockSelect

	funcTxBegin          func(ctx context.Context) (t1 pgx.Tx, err error)
	funcTxBeginOrigin    string
	inspectFuncTxBegin   func(ctx context.Context)
	afterTxBeginCounter  uint64
	beforeTxBeginCounter uint64
	TxBeginMock          mPostgresDBMockTxBegin

	funcTxExec          func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) (commandTag pgconn.CommandTag, err error)
	funcTxExecOrigin    string
	inspectFuncTxExec   func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{})
	afterTxExecCounter  uint64
	beforeTxExecCounter uint64
	TxExecMock          mPostgresDBMockTxExec

	funcTxQuery          func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) (r1 pgx.Rows, err error)
	funcTxQueryOrigin    string
	inspectFuncTxQuery   func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{})
	afterTxQueryCounter  uint64
	beforeTxQueryCounter uint64
	TxQueryMock          mPostgresDBMockTxQuery
}

// NewPostgresDBMock returns a mock for mm_dbpostgres.DBops
func NewPostgresDBMock(t minimock.Tester) *PostgresDBMock {
	m := &PostgresDBMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExecMock = mPostgresDBMockExec{mock: m}
	m.ExecMock.callArgs = []*PostgresDBMockExecParams{}

	m.ExecQueryRowMock = mPostgresDBMockExecQueryRow{mock: m}
	m.ExecQueryRowMock.callArgs = []*PostgresDBMockExecQueryRowParams{}

	m.GetMock = mPostgresDBMockGet{mock: m}
	m.GetMock.callArgs = []*PostgresDBMockGetParams{}

	m.GetPoolMock = mPostgresDBMockGetPool{mock: m}
	m.GetPoolMock.callArgs = []*PostgresDBMockGetPoolParams{}

	m.QueryMock = mPostgresDBMockQuery{mock: m}
	m.QueryMock.callArgs = []*PostgresDBMockQueryParams{}

	m.ScanAllMock = mPostgresDBMockScanAll{mock: m}
	m.ScanAllMock.callArgs = []*PostgresDBMockScanAllParams{}

	m.SelectMock = mPostgresDBMockSelect{mock: m}
	m.SelectMock.callArgs = []*PostgresDBMockSelectParams{}

	m.TxBeginMock = mPostgresDBMockTxBegin{mock: m}
	m.TxBeginMock.callArgs = []*PostgresDBMockTxBeginParams{}

	m.TxExecMock = mPostgresDBMockTxExec{mock: m}
	m.TxExecMock.callArgs = []*PostgresDBMockTxExecParams{}

	m.TxQueryMock = mPostgresDBMockTxQuery{mock: m}
	m.TxQueryMock.callArgs = []*PostgresDBMockTxQueryParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostgresDBMockExec struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockExecExpectation
	expectations       []*PostgresDBMockExecExpectation

	callArgs []*PostgresDBMockExecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockExecExpectation specifies expectation struct of the DBops.Exec
type PostgresDBMockExecExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockExecParams
	paramPtrs          *PostgresDBMockExecParamPtrs
	expectationOrigins PostgresDBMockExecExpectationOrigins
	results            *PostgresDBMockExecResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockExecParams contains parameters of the DBops.Exec
type PostgresDBMockExecParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// PostgresDBMockExecParamPtrs contains pointers to parameters of the DBops.Exec
type PostgresDBMockExecParamPtrs struct {
	ctx   *context.Context
	query *string
	args  *[]interface{}
}

// PostgresDBMockExecResults contains results of the DBops.Exec
type PostgresDBMockExecResults struct {
	c2  pgconn.CommandTag
	err error
}

// PostgresDBMockExecOrigins contains origins of expectations of the DBops.Exec
type PostgresDBMockExecExpectationOrigins struct {
	origin      string
	originCtx   string
	originQuery string
	originArgs  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mPostgresDBMockExec) Optional() *mPostgresDBMockExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for DBops.Exec
func (mmExec *mPostgresDBMockExec) Expect(ctx context.Context, query string, args ...interface{}) *mPostgresDBMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresDBMockExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &PostgresDBMockExecParams{ctx, query, args}
	mmExec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for DBops.Exec
func (mmExec *mPostgresDBMockExec) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresDBMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &PostgresDBMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx
	mmExec.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExec
}

// ExpectQueryParam2 sets up expected param query for DBops.Exec
func (mmExec *mPostgresDBMockExec) ExpectQueryParam2(query string) *mPostgresDBMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresDBMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &PostgresDBMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.query = &query
	mmExec.defaultExpectation.expectationOrigins.originQuery = minimock.CallerInfo(1)

	return mmExec
}

// ExpectArgsParam3 sets up expected param args for DBops.Exec
func (mmExec *mPostgresDBMockExec) ExpectArgsParam3(args ...interface{}) *mPostgresDBMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresDBMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &PostgresDBMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.args = &args
	mmExec.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the DBops.Exec
func (mmExec *mPostgresDBMockExec) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mPostgresDBMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by DBops.Exec
func (mmExec *mPostgresDBMockExec) Return(c2 pgconn.CommandTag, err error) *PostgresDBMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresDBMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &PostgresDBMockExecResults{c2, err}
	mmExec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// Set uses given function f to mock the DBops.Exec method
func (mmExec *mPostgresDBMockExec) Set(f func(ctx context.Context, query string, args ...interface{}) (c2 pgconn.CommandTag, err error)) *PostgresDBMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the DBops.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the DBops.Exec method")
	}

	mmExec.mock.funcExec = f
	mmExec.mock.funcExecOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// When sets expectation for the DBops.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mPostgresDBMockExec) When(ctx context.Context, query string, args ...interface{}) *PostgresDBMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresDBMock.Exec mock is already set by Set")
	}

	expectation := &PostgresDBMockExecExpectation{
		mock:               mmExec.mock,
		params:             &PostgresDBMockExecParams{ctx, query, args},
		expectationOrigins: PostgresDBMockExecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up DBops.Exec return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockExecExpectation) Then(c2 pgconn.CommandTag, err error) *PostgresDBMock {
	e.results = &PostgresDBMockExecResults{c2, err}
	return e.mock
}

// Times sets number of times DBops.Exec should be invoked
func (mmExec *mPostgresDBMockExec) Times(n uint64) *mPostgresDBMockExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of PostgresDBMock.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	mmExec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExec
}

func (mmExec *mPostgresDBMockExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements mm_dbpostgres.DBops
func (mmExec *PostgresDBMock) Exec(ctx context.Context, query string, args ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	mmExec.t.Helper()

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, query, args...)
	}

	mm_params := PostgresDBMockExecParams{ctx, query, args}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockExecParams{ctx, query, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("PostgresDBMock.Exec got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.query != nil && !minimock.Equal(*mm_want_ptrs.query, mm_got.query) {
				mmExec.t.Errorf("PostgresDBMock.Exec got unexpected parameter query, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originQuery, *mm_want_ptrs.query, mm_got.query, minimock.Diff(*mm_want_ptrs.query, mm_got.query))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmExec.t.Errorf("PostgresDBMock.Exec got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("PostgresDBMock.Exec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExec.ExecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the PostgresDBMock.Exec")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, query, args...)
	}
	mmExec.t.Fatalf("Unexpected call to PostgresDBMock.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished PostgresDBMock.Exec invocations
func (mmExec *PostgresDBMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of PostgresDBMock.Exec invocations
func (mmExec *PostgresDBMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mPostgresDBMockExec) Calls() []*PostgresDBMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*PostgresDBMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.Exec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.Exec at\n%s", m.ExecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.Exec at\n%s with params: %#v", m.ExecMock.defaultExpectation.expectationOrigins.origin, *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.Exec at\n%s", m.funcExecOrigin)
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.Exec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), m.ExecMock.expectedInvocationsOrigin, afterExecCounter)
	}
}

type mPostgresDBMockExecQueryRow struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockExecQueryRowExpectation
	expectations       []*PostgresDBMockExecQueryRowExpectation

	callArgs []*PostgresDBMockExecQueryRowParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockExecQueryRowExpectation specifies expectation struct of the DBops.ExecQueryRow
type PostgresDBMockExecQueryRowExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockExecQueryRowParams
	paramPtrs          *PostgresDBMockExecQueryRowParamPtrs
	expectationOrigins PostgresDBMockExecQueryRowExpectationOrigins
	results            *PostgresDBMockExecQueryRowResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockExecQueryRowParams contains parameters of the DBops.ExecQueryRow
type PostgresDBMockExecQueryRowParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// PostgresDBMockExecQueryRowParamPtrs contains pointers to parameters of the DBops.ExecQueryRow
type PostgresDBMockExecQueryRowParamPtrs struct {
	ctx   *context.Context
	query *string
	args  *[]interface{}
}

// PostgresDBMockExecQueryRowResults contains results of the DBops.ExecQueryRow
type PostgresDBMockExecQueryRowResults struct {
	r1 pgx.Row
}

// PostgresDBMockExecQueryRowOrigins contains origins of expectations of the DBops.ExecQueryRow
type PostgresDBMockExecQueryRowExpectationOrigins struct {
	origin      string
	originCtx   string
	originQuery string
	originArgs  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Optional() *mPostgresDBMockExecQueryRow {
	mmExecQueryRow.optional = true
	return mmExecQueryRow
}

// Expect sets up expected params for DBops.ExecQueryRow
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Expect(ctx context.Context, query string, args ...interface{}) *mPostgresDBMockExecQueryRow {
	if mmExecQueryRow.mock.funcExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Set")
	}

	if mmExecQueryRow.defaultExpectation == nil {
		mmExecQueryRow.defaultExpectation = &PostgresDBMockExecQueryRowExpectation{}
	}

	if mmExecQueryRow.defaultExpectation.paramPtrs != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by ExpectParams functions")
	}

	mmExecQueryRow.defaultExpectation.params = &PostgresDBMockExecQueryRowParams{ctx, query, args}
	mmExecQueryRow.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExecQueryRow.expectations {
		if minimock.Equal(e.params, mmExecQueryRow.defaultExpectation.params) {
			mmExecQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecQueryRow.defaultExpectation.params)
		}
	}

	return mmExecQueryRow
}

// ExpectCtxParam1 sets up expected param ctx for DBops.ExecQueryRow
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockExecQueryRow {
	if mmExecQueryRow.mock.funcExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Set")
	}

	if mmExecQueryRow.defaultExpectation == nil {
		mmExecQueryRow.defaultExpectation = &PostgresDBMockExecQueryRowExpectation{}
	}

	if mmExecQueryRow.defaultExpectation.params != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Expect")
	}

	if mmExecQueryRow.defaultExpectation.paramPtrs == nil {
		mmExecQueryRow.defaultExpectation.paramPtrs = &PostgresDBMockExecQueryRowParamPtrs{}
	}
	mmExecQueryRow.defaultExpectation.paramPtrs.ctx = &ctx
	mmExecQueryRow.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExecQueryRow
}

// ExpectQueryParam2 sets up expected param query for DBops.ExecQueryRow
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) ExpectQueryParam2(query string) *mPostgresDBMockExecQueryRow {
	if mmExecQueryRow.mock.funcExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Set")
	}

	if mmExecQueryRow.defaultExpectation == nil {
		mmExecQueryRow.defaultExpectation = &PostgresDBMockExecQueryRowExpectation{}
	}

	if mmExecQueryRow.defaultExpectation.params != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Expect")
	}

	if mmExecQueryRow.defaultExpectation.paramPtrs == nil {
		mmExecQueryRow.defaultExpectation.paramPtrs = &PostgresDBMockExecQueryRowParamPtrs{}
	}
	mmExecQueryRow.defaultExpectation.paramPtrs.query = &query
	mmExecQueryRow.defaultExpectation.expectationOrigins.originQuery = minimock.CallerInfo(1)

	return mmExecQueryRow
}

// ExpectArgsParam3 sets up expected param args for DBops.ExecQueryRow
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) ExpectArgsParam3(args ...interface{}) *mPostgresDBMockExecQueryRow {
	if mmExecQueryRow.mock.funcExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Set")
	}

	if mmExecQueryRow.defaultExpectation == nil {
		mmExecQueryRow.defaultExpectation = &PostgresDBMockExecQueryRowExpectation{}
	}

	if mmExecQueryRow.defaultExpectation.params != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Expect")
	}

	if mmExecQueryRow.defaultExpectation.paramPtrs == nil {
		mmExecQueryRow.defaultExpectation.paramPtrs = &PostgresDBMockExecQueryRowParamPtrs{}
	}
	mmExecQueryRow.defaultExpectation.paramPtrs.args = &args
	mmExecQueryRow.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmExecQueryRow
}

// Inspect accepts an inspector function that has same arguments as the DBops.ExecQueryRow
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mPostgresDBMockExecQueryRow {
	if mmExecQueryRow.mock.inspectFuncExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.ExecQueryRow")
	}

	mmExecQueryRow.mock.inspectFuncExecQueryRow = f

	return mmExecQueryRow
}

// Return sets up results that will be returned by DBops.ExecQueryRow
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Return(r1 pgx.Row) *PostgresDBMock {
	if mmExecQueryRow.mock.funcExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Set")
	}

	if mmExecQueryRow.defaultExpectation == nil {
		mmExecQueryRow.defaultExpectation = &PostgresDBMockExecQueryRowExpectation{mock: mmExecQueryRow.mock}
	}
	mmExecQueryRow.defaultExpectation.results = &PostgresDBMockExecQueryRowResults{r1}
	mmExecQueryRow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExecQueryRow.mock
}

// Set uses given function f to mock the DBops.ExecQueryRow method
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 pgx.Row)) *PostgresDBMock {
	if mmExecQueryRow.defaultExpectation != nil {
		mmExecQueryRow.mock.t.Fatalf("Default expectation is already set for the DBops.ExecQueryRow method")
	}

	if len(mmExecQueryRow.expectations) > 0 {
		mmExecQueryRow.mock.t.Fatalf("Some expectations are already set for the DBops.ExecQueryRow method")
	}

	mmExecQueryRow.mock.funcExecQueryRow = f
	mmExecQueryRow.mock.funcExecQueryRowOrigin = minimock.CallerInfo(1)
	return mmExecQueryRow.mock
}

// When sets expectation for the DBops.ExecQueryRow which will trigger the result defined by the following
// Then helper
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) When(ctx context.Context, query string, args ...interface{}) *PostgresDBMockExecQueryRowExpectation {
	if mmExecQueryRow.mock.funcExecQueryRow != nil {
		mmExecQueryRow.mock.t.Fatalf("PostgresDBMock.ExecQueryRow mock is already set by Set")
	}

	expectation := &PostgresDBMockExecQueryRowExpectation{
		mock:               mmExecQueryRow.mock,
		params:             &PostgresDBMockExecQueryRowParams{ctx, query, args},
		expectationOrigins: PostgresDBMockExecQueryRowExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExecQueryRow.expectations = append(mmExecQueryRow.expectations, expectation)
	return expectation
}

// Then sets up DBops.ExecQueryRow return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockExecQueryRowExpectation) Then(r1 pgx.Row) *PostgresDBMock {
	e.results = &PostgresDBMockExecQueryRowResults{r1}
	return e.mock
}

// Times sets number of times DBops.ExecQueryRow should be invoked
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Times(n uint64) *mPostgresDBMockExecQueryRow {
	if n == 0 {
		mmExecQueryRow.mock.t.Fatalf("Times of PostgresDBMock.ExecQueryRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExecQueryRow.expectedInvocations, n)
	mmExecQueryRow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExecQueryRow
}

func (mmExecQueryRow *mPostgresDBMockExecQueryRow) invocationsDone() bool {
	if len(mmExecQueryRow.expectations) == 0 && mmExecQueryRow.defaultExpectation == nil && mmExecQueryRow.mock.funcExecQueryRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExecQueryRow.mock.afterExecQueryRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExecQueryRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExecQueryRow implements mm_dbpostgres.DBops
func (mmExecQueryRow *PostgresDBMock) ExecQueryRow(ctx context.Context, query string, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmExecQueryRow.beforeExecQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmExecQueryRow.afterExecQueryRowCounter, 1)

	mmExecQueryRow.t.Helper()

	if mmExecQueryRow.inspectFuncExecQueryRow != nil {
		mmExecQueryRow.inspectFuncExecQueryRow(ctx, query, args...)
	}

	mm_params := PostgresDBMockExecQueryRowParams{ctx, query, args}

	// Record call args
	mmExecQueryRow.ExecQueryRowMock.mutex.Lock()
	mmExecQueryRow.ExecQueryRowMock.callArgs = append(mmExecQueryRow.ExecQueryRowMock.callArgs, &mm_params)
	mmExecQueryRow.ExecQueryRowMock.mutex.Unlock()

	for _, e := range mmExecQueryRow.ExecQueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmExecQueryRow.ExecQueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecQueryRow.ExecQueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmExecQueryRow.ExecQueryRowMock.defaultExpectation.params
		mm_want_ptrs := mmExecQueryRow.ExecQueryRowMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockExecQueryRowParams{ctx, query, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExecQueryRow.t.Errorf("PostgresDBMock.ExecQueryRow got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecQueryRow.ExecQueryRowMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.query != nil && !minimock.Equal(*mm_want_ptrs.query, mm_got.query) {
				mmExecQueryRow.t.Errorf("PostgresDBMock.ExecQueryRow got unexpected parameter query, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecQueryRow.ExecQueryRowMock.defaultExpectation.expectationOrigins.originQuery, *mm_want_ptrs.query, mm_got.query, minimock.Diff(*mm_want_ptrs.query, mm_got.query))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmExecQueryRow.t.Errorf("PostgresDBMock.ExecQueryRow got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecQueryRow.ExecQueryRowMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecQueryRow.t.Errorf("PostgresDBMock.ExecQueryRow got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExecQueryRow.ExecQueryRowMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecQueryRow.ExecQueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmExecQueryRow.t.Fatal("No results are set for the PostgresDBMock.ExecQueryRow")
		}
		return (*mm_results).r1
	}
	if mmExecQueryRow.funcExecQueryRow != nil {
		return mmExecQueryRow.funcExecQueryRow(ctx, query, args...)
	}
	mmExecQueryRow.t.Fatalf("Unexpected call to PostgresDBMock.ExecQueryRow. %v %v %v", ctx, query, args)
	return
}

// ExecQueryRowAfterCounter returns a count of finished PostgresDBMock.ExecQueryRow invocations
func (mmExecQueryRow *PostgresDBMock) ExecQueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecQueryRow.afterExecQueryRowCounter)
}

// ExecQueryRowBeforeCounter returns a count of PostgresDBMock.ExecQueryRow invocations
func (mmExecQueryRow *PostgresDBMock) ExecQueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecQueryRow.beforeExecQueryRowCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.ExecQueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecQueryRow *mPostgresDBMockExecQueryRow) Calls() []*PostgresDBMockExecQueryRowParams {
	mmExecQueryRow.mutex.RLock()

	argCopy := make([]*PostgresDBMockExecQueryRowParams, len(mmExecQueryRow.callArgs))
	copy(argCopy, mmExecQueryRow.callArgs)

	mmExecQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockExecQueryRowDone returns true if the count of the ExecQueryRow invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockExecQueryRowDone() bool {
	if m.ExecQueryRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecQueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecQueryRowMock.invocationsDone()
}

// MinimockExecQueryRowInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockExecQueryRowInspect() {
	for _, e := range m.ExecQueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.ExecQueryRow at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecQueryRowCounter := mm_atomic.LoadUint64(&m.afterExecQueryRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecQueryRowMock.defaultExpectation != nil && afterExecQueryRowCounter < 1 {
		if m.ExecQueryRowMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.ExecQueryRow at\n%s", m.ExecQueryRowMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.ExecQueryRow at\n%s with params: %#v", m.ExecQueryRowMock.defaultExpectation.expectationOrigins.origin, *m.ExecQueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecQueryRow != nil && afterExecQueryRowCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.ExecQueryRow at\n%s", m.funcExecQueryRowOrigin)
	}

	if !m.ExecQueryRowMock.invocationsDone() && afterExecQueryRowCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.ExecQueryRow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecQueryRowMock.expectedInvocations), m.ExecQueryRowMock.expectedInvocationsOrigin, afterExecQueryRowCounter)
	}
}

type mPostgresDBMockGet struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockGetExpectation
	expectations       []*PostgresDBMockGetExpectation

	callArgs []*PostgresDBMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockGetExpectation specifies expectation struct of the DBops.Get
type PostgresDBMockGetExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockGetParams
	paramPtrs          *PostgresDBMockGetParamPtrs
	expectationOrigins PostgresDBMockGetExpectationOrigins
	results            *PostgresDBMockGetResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockGetParams contains parameters of the DBops.Get
type PostgresDBMockGetParams struct {
	ctx   context.Context
	dest  interface{}
	query string
	args  []interface{}
}

// PostgresDBMockGetParamPtrs contains pointers to parameters of the DBops.Get
type PostgresDBMockGetParamPtrs struct {
	ctx   *context.Context
	dest  *interface{}
	query *string
	args  *[]interface{}
}

// PostgresDBMockGetResults contains results of the DBops.Get
type PostgresDBMockGetResults struct {
	err error
}

// PostgresDBMockGetOrigins contains origins of expectations of the DBops.Get
type PostgresDBMockGetExpectationOrigins struct {
	origin      string
	originCtx   string
	originDest  string
	originQuery string
	originArgs  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mPostgresDBMockGet) Optional() *mPostgresDBMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for DBops.Get
func (mmGet *mPostgresDBMockGet) Expect(ctx context.Context, dest interface{}, query string, args ...interface{}) *mPostgresDBMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresDBMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &PostgresDBMockGetParams{ctx, dest, query, args}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for DBops.Get
func (mmGet *mPostgresDBMockGet) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresDBMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &PostgresDBMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectDestParam2 sets up expected param dest for DBops.Get
func (mmGet *mPostgresDBMockGet) ExpectDestParam2(dest interface{}) *mPostgresDBMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresDBMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &PostgresDBMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.dest = &dest
	mmGet.defaultExpectation.expectationOrigins.originDest = minimock.CallerInfo(1)

	return mmGet
}

// ExpectQueryParam3 sets up expected param query for DBops.Get
func (mmGet *mPostgresDBMockGet) ExpectQueryParam3(query string) *mPostgresDBMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresDBMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &PostgresDBMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.query = &query
	mmGet.defaultExpectation.expectationOrigins.originQuery = minimock.CallerInfo(1)

	return mmGet
}

// ExpectArgsParam4 sets up expected param args for DBops.Get
func (mmGet *mPostgresDBMockGet) ExpectArgsParam4(args ...interface{}) *mPostgresDBMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresDBMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &PostgresDBMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.args = &args
	mmGet.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the DBops.Get
func (mmGet *mPostgresDBMockGet) Inspect(f func(ctx context.Context, dest interface{}, query string, args ...interface{})) *mPostgresDBMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by DBops.Get
func (mmGet *mPostgresDBMockGet) Return(err error) *PostgresDBMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresDBMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &PostgresDBMockGetResults{err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the DBops.Get method
func (mmGet *mPostgresDBMockGet) Set(f func(ctx context.Context, dest interface{}, query string, args ...interface{}) (err error)) *PostgresDBMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the DBops.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the DBops.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the DBops.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mPostgresDBMockGet) When(ctx context.Context, dest interface{}, query string, args ...interface{}) *PostgresDBMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresDBMock.Get mock is already set by Set")
	}

	expectation := &PostgresDBMockGetExpectation{
		mock:               mmGet.mock,
		params:             &PostgresDBMockGetParams{ctx, dest, query, args},
		expectationOrigins: PostgresDBMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up DBops.Get return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockGetExpectation) Then(err error) *PostgresDBMock {
	e.results = &PostgresDBMockGetResults{err}
	return e.mock
}

// Times sets number of times DBops.Get should be invoked
func (mmGet *mPostgresDBMockGet) Times(n uint64) *mPostgresDBMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of PostgresDBMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mPostgresDBMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_dbpostgres.DBops
func (mmGet *PostgresDBMock) Get(ctx context.Context, dest interface{}, query string, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, dest, query, args...)
	}

	mm_params := PostgresDBMockGetParams{ctx, dest, query, args}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockGetParams{ctx, dest, query, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("PostgresDBMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dest != nil && !minimock.Equal(*mm_want_ptrs.dest, mm_got.dest) {
				mmGet.t.Errorf("PostgresDBMock.Get got unexpected parameter dest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originDest, *mm_want_ptrs.dest, mm_got.dest, minimock.Diff(*mm_want_ptrs.dest, mm_got.dest))
			}

			if mm_want_ptrs.query != nil && !minimock.Equal(*mm_want_ptrs.query, mm_got.query) {
				mmGet.t.Errorf("PostgresDBMock.Get got unexpected parameter query, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originQuery, *mm_want_ptrs.query, mm_got.query, minimock.Diff(*mm_want_ptrs.query, mm_got.query))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmGet.t.Errorf("PostgresDBMock.Get got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("PostgresDBMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the PostgresDBMock.Get")
		}
		return (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, dest, query, args...)
	}
	mmGet.t.Fatalf("Unexpected call to PostgresDBMock.Get. %v %v %v %v", ctx, dest, query, args)
	return
}

// GetAfterCounter returns a count of finished PostgresDBMock.Get invocations
func (mmGet *PostgresDBMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of PostgresDBMock.Get invocations
func (mmGet *PostgresDBMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mPostgresDBMockGet) Calls() []*PostgresDBMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*PostgresDBMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mPostgresDBMockGetPool struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockGetPoolExpectation
	expectations       []*PostgresDBMockGetPoolExpectation

	callArgs []*PostgresDBMockGetPoolParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockGetPoolExpectation specifies expectation struct of the DBops.GetPool
type PostgresDBMockGetPoolExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockGetPoolParams
	paramPtrs          *PostgresDBMockGetPoolParamPtrs
	expectationOrigins PostgresDBMockGetPoolExpectationOrigins
	results            *PostgresDBMockGetPoolResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockGetPoolParams contains parameters of the DBops.GetPool
type PostgresDBMockGetPoolParams struct {
	ctx context.Context
}

// PostgresDBMockGetPoolParamPtrs contains pointers to parameters of the DBops.GetPool
type PostgresDBMockGetPoolParamPtrs struct {
	ctx *context.Context
}

// PostgresDBMockGetPoolResults contains results of the DBops.GetPool
type PostgresDBMockGetPoolResults struct {
	pp1 *pgxpool.Pool
}

// PostgresDBMockGetPoolOrigins contains origins of expectations of the DBops.GetPool
type PostgresDBMockGetPoolExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPool *mPostgresDBMockGetPool) Optional() *mPostgresDBMockGetPool {
	mmGetPool.optional = true
	return mmGetPool
}

// Expect sets up expected params for DBops.GetPool
func (mmGetPool *mPostgresDBMockGetPool) Expect(ctx context.Context) *mPostgresDBMockGetPool {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresDBMock.GetPool mock is already set by Set")
	}

	if mmGetPool.defaultExpectation == nil {
		mmGetPool.defaultExpectation = &PostgresDBMockGetPoolExpectation{}
	}

	if mmGetPool.defaultExpectation.paramPtrs != nil {
		mmGetPool.mock.t.Fatalf("PostgresDBMock.GetPool mock is already set by ExpectParams functions")
	}

	mmGetPool.defaultExpectation.params = &PostgresDBMockGetPoolParams{ctx}
	mmGetPool.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPool.expectations {
		if minimock.Equal(e.params, mmGetPool.defaultExpectation.params) {
			mmGetPool.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPool.defaultExpectation.params)
		}
	}

	return mmGetPool
}

// ExpectCtxParam1 sets up expected param ctx for DBops.GetPool
func (mmGetPool *mPostgresDBMockGetPool) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockGetPool {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresDBMock.GetPool mock is already set by Set")
	}

	if mmGetPool.defaultExpectation == nil {
		mmGetPool.defaultExpectation = &PostgresDBMockGetPoolExpectation{}
	}

	if mmGetPool.defaultExpectation.params != nil {
		mmGetPool.mock.t.Fatalf("PostgresDBMock.GetPool mock is already set by Expect")
	}

	if mmGetPool.defaultExpectation.paramPtrs == nil {
		mmGetPool.defaultExpectation.paramPtrs = &PostgresDBMockGetPoolParamPtrs{}
	}
	mmGetPool.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPool.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPool
}

// Inspect accepts an inspector function that has same arguments as the DBops.GetPool
func (mmGetPool *mPostgresDBMockGetPool) Inspect(f func(ctx context.Context)) *mPostgresDBMockGetPool {
	if mmGetPool.mock.inspectFuncGetPool != nil {
		mmGetPool.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.GetPool")
	}

	mmGetPool.mock.inspectFuncGetPool = f

	return mmGetPool
}

// Return sets up results that will be returned by DBops.GetPool
func (mmGetPool *mPostgresDBMockGetPool) Return(pp1 *pgxpool.Pool) *PostgresDBMock {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresDBMock.GetPool mock is already set by Set")
	}

	if mmGetPool.defaultExpectation == nil {
		mmGetPool.defaultExpectation = &PostgresDBMockGetPoolExpectation{mock: mmGetPool.mock}
	}
	mmGetPool.defaultExpectation.results = &PostgresDBMockGetPoolResults{pp1}
	mmGetPool.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPool.mock
}

// Set uses given function f to mock the DBops.GetPool method
func (mmGetPool *mPostgresDBMockGetPool) Set(f func(ctx context.Context) (pp1 *pgxpool.Pool)) *PostgresDBMock {
	if mmGetPool.defaultExpectation != nil {
		mmGetPool.mock.t.Fatalf("Default expectation is already set for the DBops.GetPool method")
	}

	if len(mmGetPool.expectations) > 0 {
		mmGetPool.mock.t.Fatalf("Some expectations are already set for the DBops.GetPool method")
	}

	mmGetPool.mock.funcGetPool = f
	mmGetPool.mock.funcGetPoolOrigin = minimock.CallerInfo(1)
	return mmGetPool.mock
}

// When sets expectation for the DBops.GetPool which will trigger the result defined by the following
// Then helper
func (mmGetPool *mPostgresDBMockGetPool) When(ctx context.Context) *PostgresDBMockGetPoolExpectation {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresDBMock.GetPool mock is already set by Set")
	}

	expectation := &PostgresDBMockGetPoolExpectation{
		mock:               mmGetPool.mock,
		params:             &PostgresDBMockGetPoolParams{ctx},
		expectationOrigins: PostgresDBMockGetPoolExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPool.expectations = append(mmGetPool.expectations, expectation)
	return expectation
}

// Then sets up DBops.GetPool return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockGetPoolExpectation) Then(pp1 *pgxpool.Pool) *PostgresDBMock {
	e.results = &PostgresDBMockGetPoolResults{pp1}
	return e.mock
}

// Times sets number of times DBops.GetPool should be invoked
func (mmGetPool *mPostgresDBMockGetPool) Times(n uint64) *mPostgresDBMockGetPool {
	if n == 0 {
		mmGetPool.mock.t.Fatalf("Times of PostgresDBMock.GetPool mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPool.expectedInvocations, n)
	mmGetPool.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPool
}

func (mmGetPool *mPostgresDBMockGetPool) invocationsDone() bool {
	if len(mmGetPool.expectations) == 0 && mmGetPool.defaultExpectation == nil && mmGetPool.mock.funcGetPool == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPool.mock.afterGetPoolCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPool.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPool implements mm_dbpostgres.DBops
func (mmGetPool *PostgresDBMock) GetPool(ctx context.Context) (pp1 *pgxpool.Pool) {
	mm_atomic.AddUint64(&mmGetPool.beforeGetPoolCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPool.afterGetPoolCounter, 1)

	mmGetPool.t.Helper()

	if mmGetPool.inspectFuncGetPool != nil {
		mmGetPool.inspectFuncGetPool(ctx)
	}

	mm_params := PostgresDBMockGetPoolParams{ctx}

	// Record call args
	mmGetPool.GetPoolMock.mutex.Lock()
	mmGetPool.GetPoolMock.callArgs = append(mmGetPool.GetPoolMock.callArgs, &mm_params)
	mmGetPool.GetPoolMock.mutex.Unlock()

	for _, e := range mmGetPool.GetPoolMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1
		}
	}

	if mmGetPool.GetPoolMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPool.GetPoolMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPool.GetPoolMock.defaultExpectation.params
		mm_want_ptrs := mmGetPool.GetPoolMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockGetPoolParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPool.t.Errorf("PostgresDBMock.GetPool got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPool.GetPoolMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPool.t.Errorf("PostgresDBMock.GetPool got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPool.GetPoolMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPool.GetPoolMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPool.t.Fatal("No results are set for the PostgresDBMock.GetPool")
		}
		return (*mm_results).pp1
	}
	if mmGetPool.funcGetPool != nil {
		return mmGetPool.funcGetPool(ctx)
	}
	mmGetPool.t.Fatalf("Unexpected call to PostgresDBMock.GetPool. %v", ctx)
	return
}

// GetPoolAfterCounter returns a count of finished PostgresDBMock.GetPool invocations
func (mmGetPool *PostgresDBMock) GetPoolAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPool.afterGetPoolCounter)
}

// GetPoolBeforeCounter returns a count of PostgresDBMock.GetPool invocations
func (mmGetPool *PostgresDBMock) GetPoolBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPool.beforeGetPoolCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.GetPool.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPool *mPostgresDBMockGetPool) Calls() []*PostgresDBMockGetPoolParams {
	mmGetPool.mutex.RLock()

	argCopy := make([]*PostgresDBMockGetPoolParams, len(mmGetPool.callArgs))
	copy(argCopy, mmGetPool.callArgs)

	mmGetPool.mutex.RUnlock()

	return argCopy
}

// MinimockGetPoolDone returns true if the count of the GetPool invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockGetPoolDone() bool {
	if m.GetPoolMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPoolMock.invocationsDone()
}

// MinimockGetPoolInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockGetPoolInspect() {
	for _, e := range m.GetPoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.GetPool at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPoolCounter := mm_atomic.LoadUint64(&m.afterGetPoolCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPoolMock.defaultExpectation != nil && afterGetPoolCounter < 1 {
		if m.GetPoolMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.GetPool at\n%s", m.GetPoolMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.GetPool at\n%s with params: %#v", m.GetPoolMock.defaultExpectation.expectationOrigins.origin, *m.GetPoolMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPool != nil && afterGetPoolCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.GetPool at\n%s", m.funcGetPoolOrigin)
	}

	if !m.GetPoolMock.invocationsDone() && afterGetPoolCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.GetPool at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPoolMock.expectedInvocations), m.GetPoolMock.expectedInvocationsOrigin, afterGetPoolCounter)
	}
}

type mPostgresDBMockQuery struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockQueryExpectation
	expectations       []*PostgresDBMockQueryExpectation

	callArgs []*PostgresDBMockQueryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockQueryExpectation specifies expectation struct of the DBops.Query
type PostgresDBMockQueryExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockQueryParams
	paramPtrs          *PostgresDBMockQueryParamPtrs
	expectationOrigins PostgresDBMockQueryExpectationOrigins
	results            *PostgresDBMockQueryResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockQueryParams contains parameters of the DBops.Query
type PostgresDBMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// PostgresDBMockQueryParamPtrs contains pointers to parameters of the DBops.Query
type PostgresDBMockQueryParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]interface{}
}

// PostgresDBMockQueryResults contains results of the DBops.Query
type PostgresDBMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// PostgresDBMockQueryOrigins contains origins of expectations of the DBops.Query
type PostgresDBMockQueryExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuery *mPostgresDBMockQuery) Optional() *mPostgresDBMockQuery {
	mmQuery.optional = true
	return mmQuery
}

// Expect sets up expected params for DBops.Query
func (mmQuery *mPostgresDBMockQuery) Expect(ctx context.Context, sql string, args ...interface{}) *mPostgresDBMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresDBMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.paramPtrs != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by ExpectParams functions")
	}

	mmQuery.defaultExpectation.params = &PostgresDBMockQueryParams{ctx, sql, args}
	mmQuery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// ExpectCtxParam1 sets up expected param ctx for DBops.Query
func (mmQuery *mPostgresDBMockQuery) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresDBMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &PostgresDBMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectSqlParam2 sets up expected param sql for DBops.Query
func (mmQuery *mPostgresDBMockQuery) ExpectSqlParam2(sql string) *mPostgresDBMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresDBMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &PostgresDBMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.sql = &sql
	mmQuery.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectArgsParam3 sets up expected param args for DBops.Query
func (mmQuery *mPostgresDBMockQuery) ExpectArgsParam3(args ...interface{}) *mPostgresDBMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresDBMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &PostgresDBMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.args = &args
	mmQuery.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the DBops.Query
func (mmQuery *mPostgresDBMockQuery) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mPostgresDBMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by DBops.Query
func (mmQuery *mPostgresDBMockQuery) Return(r1 pgx.Rows, err error) *PostgresDBMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresDBMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &PostgresDBMockQueryResults{r1, err}
	mmQuery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// Set uses given function f to mock the DBops.Query method
func (mmQuery *mPostgresDBMockQuery) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error)) *PostgresDBMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the DBops.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the DBops.Query method")
	}

	mmQuery.mock.funcQuery = f
	mmQuery.mock.funcQueryOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// When sets expectation for the DBops.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mPostgresDBMockQuery) When(ctx context.Context, sql string, args ...interface{}) *PostgresDBMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresDBMock.Query mock is already set by Set")
	}

	expectation := &PostgresDBMockQueryExpectation{
		mock:               mmQuery.mock,
		params:             &PostgresDBMockQueryParams{ctx, sql, args},
		expectationOrigins: PostgresDBMockQueryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up DBops.Query return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockQueryExpectation) Then(r1 pgx.Rows, err error) *PostgresDBMock {
	e.results = &PostgresDBMockQueryResults{r1, err}
	return e.mock
}

// Times sets number of times DBops.Query should be invoked
func (mmQuery *mPostgresDBMockQuery) Times(n uint64) *mPostgresDBMockQuery {
	if n == 0 {
		mmQuery.mock.t.Fatalf("Times of PostgresDBMock.Query mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuery.expectedInvocations, n)
	mmQuery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuery
}

func (mmQuery *mPostgresDBMockQuery) invocationsDone() bool {
	if len(mmQuery.expectations) == 0 && mmQuery.defaultExpectation == nil && mmQuery.mock.funcQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuery.mock.afterQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Query implements mm_dbpostgres.DBops
func (mmQuery *PostgresDBMock) Query(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	mmQuery.t.Helper()

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := PostgresDBMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_want_ptrs := mmQuery.QueryMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockQueryParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuery.t.Errorf("PostgresDBMock.Query got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQuery.t.Errorf("PostgresDBMock.Query got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQuery.t.Errorf("PostgresDBMock.Query got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("PostgresDBMock.Query got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuery.QueryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the PostgresDBMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to PostgresDBMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished PostgresDBMock.Query invocations
func (mmQuery *PostgresDBMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of PostgresDBMock.Query invocations
func (mmQuery *PostgresDBMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mPostgresDBMockQuery) Calls() []*PostgresDBMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*PostgresDBMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockQueryDone() bool {
	if m.QueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryMock.invocationsDone()
}

// MinimockQueryInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.Query at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryCounter := mm_atomic.LoadUint64(&m.afterQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && afterQueryCounter < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.Query at\n%s", m.QueryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.Query at\n%s with params: %#v", m.QueryMock.defaultExpectation.expectationOrigins.origin, *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && afterQueryCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.Query at\n%s", m.funcQueryOrigin)
	}

	if !m.QueryMock.invocationsDone() && afterQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.Query at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryMock.expectedInvocations), m.QueryMock.expectedInvocationsOrigin, afterQueryCounter)
	}
}

type mPostgresDBMockScanAll struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockScanAllExpectation
	expectations       []*PostgresDBMockScanAllExpectation

	callArgs []*PostgresDBMockScanAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockScanAllExpectation specifies expectation struct of the DBops.ScanAll
type PostgresDBMockScanAllExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockScanAllParams
	paramPtrs          *PostgresDBMockScanAllParamPtrs
	expectationOrigins PostgresDBMockScanAllExpectationOrigins
	results            *PostgresDBMockScanAllResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockScanAllParams contains parameters of the DBops.ScanAll
type PostgresDBMockScanAllParams struct {
	dst  interface{}
	rows pgx.Rows
}

// PostgresDBMockScanAllParamPtrs contains pointers to parameters of the DBops.ScanAll
type PostgresDBMockScanAllParamPtrs struct {
	dst  *interface{}
	rows *pgx.Rows
}

// PostgresDBMockScanAllResults contains results of the DBops.ScanAll
type PostgresDBMockScanAllResults struct {
	err error
}

// PostgresDBMockScanAllOrigins contains origins of expectations of the DBops.ScanAll
type PostgresDBMockScanAllExpectationOrigins struct {
	origin     string
	originDst  string
	originRows string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScanAll *mPostgresDBMockScanAll) Optional() *mPostgresDBMockScanAll {
	mmScanAll.optional = true
	return mmScanAll
}

// Expect sets up expected params for DBops.ScanAll
func (mmScanAll *mPostgresDBMockScanAll) Expect(dst interface{}, rows pgx.Rows) *mPostgresDBMockScanAll {
	if mmScanAll.mock.funcScanAll != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Set")
	}

	if mmScanAll.defaultExpectation == nil {
		mmScanAll.defaultExpectation = &PostgresDBMockScanAllExpectation{}
	}

	if mmScanAll.defaultExpectation.paramPtrs != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by ExpectParams functions")
	}

	mmScanAll.defaultExpectation.params = &PostgresDBMockScanAllParams{dst, rows}
	mmScanAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScanAll.expectations {
		if minimock.Equal(e.params, mmScanAll.defaultExpectation.params) {
			mmScanAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanAll.defaultExpectation.params)
		}
	}

	return mmScanAll
}

// ExpectDstParam1 sets up expected param dst for DBops.ScanAll
func (mmScanAll *mPostgresDBMockScanAll) ExpectDstParam1(dst interface{}) *mPostgresDBMockScanAll {
	if mmScanAll.mock.funcScanAll != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Set")
	}

	if mmScanAll.defaultExpectation == nil {
		mmScanAll.defaultExpectation = &PostgresDBMockScanAllExpectation{}
	}

	if mmScanAll.defaultExpectation.params != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Expect")
	}

	if mmScanAll.defaultExpectation.paramPtrs == nil {
		mmScanAll.defaultExpectation.paramPtrs = &PostgresDBMockScanAllParamPtrs{}
	}
	mmScanAll.defaultExpectation.paramPtrs.dst = &dst
	mmScanAll.defaultExpectation.expectationOrigins.originDst = minimock.CallerInfo(1)

	return mmScanAll
}

// ExpectRowsParam2 sets up expected param rows for DBops.ScanAll
func (mmScanAll *mPostgresDBMockScanAll) ExpectRowsParam2(rows pgx.Rows) *mPostgresDBMockScanAll {
	if mmScanAll.mock.funcScanAll != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Set")
	}

	if mmScanAll.defaultExpectation == nil {
		mmScanAll.defaultExpectation = &PostgresDBMockScanAllExpectation{}
	}

	if mmScanAll.defaultExpectation.params != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Expect")
	}

	if mmScanAll.defaultExpectation.paramPtrs == nil {
		mmScanAll.defaultExpectation.paramPtrs = &PostgresDBMockScanAllParamPtrs{}
	}
	mmScanAll.defaultExpectation.paramPtrs.rows = &rows
	mmScanAll.defaultExpectation.expectationOrigins.originRows = minimock.CallerInfo(1)

	return mmScanAll
}

// Inspect accepts an inspector function that has same arguments as the DBops.ScanAll
func (mmScanAll *mPostgresDBMockScanAll) Inspect(f func(dst interface{}, rows pgx.Rows)) *mPostgresDBMockScanAll {
	if mmScanAll.mock.inspectFuncScanAll != nil {
		mmScanAll.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.ScanAll")
	}

	mmScanAll.mock.inspectFuncScanAll = f

	return mmScanAll
}

// Return sets up results that will be returned by DBops.ScanAll
func (mmScanAll *mPostgresDBMockScanAll) Return(err error) *PostgresDBMock {
	if mmScanAll.mock.funcScanAll != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Set")
	}

	if mmScanAll.defaultExpectation == nil {
		mmScanAll.defaultExpectation = &PostgresDBMockScanAllExpectation{mock: mmScanAll.mock}
	}
	mmScanAll.defaultExpectation.results = &PostgresDBMockScanAllResults{err}
	mmScanAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScanAll.mock
}

// Set uses given function f to mock the DBops.ScanAll method
func (mmScanAll *mPostgresDBMockScanAll) Set(f func(dst interface{}, rows pgx.Rows) (err error)) *PostgresDBMock {
	if mmScanAll.defaultExpectation != nil {
		mmScanAll.mock.t.Fatalf("Default expectation is already set for the DBops.ScanAll method")
	}

	if len(mmScanAll.expectations) > 0 {
		mmScanAll.mock.t.Fatalf("Some expectations are already set for the DBops.ScanAll method")
	}

	mmScanAll.mock.funcScanAll = f
	mmScanAll.mock.funcScanAllOrigin = minimock.CallerInfo(1)
	return mmScanAll.mock
}

// When sets expectation for the DBops.ScanAll which will trigger the result defined by the following
// Then helper
func (mmScanAll *mPostgresDBMockScanAll) When(dst interface{}, rows pgx.Rows) *PostgresDBMockScanAllExpectation {
	if mmScanAll.mock.funcScanAll != nil {
		mmScanAll.mock.t.Fatalf("PostgresDBMock.ScanAll mock is already set by Set")
	}

	expectation := &PostgresDBMockScanAllExpectation{
		mock:               mmScanAll.mock,
		params:             &PostgresDBMockScanAllParams{dst, rows},
		expectationOrigins: PostgresDBMockScanAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScanAll.expectations = append(mmScanAll.expectations, expectation)
	return expectation
}

// Then sets up DBops.ScanAll return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockScanAllExpectation) Then(err error) *PostgresDBMock {
	e.results = &PostgresDBMockScanAllResults{err}
	return e.mock
}

// Times sets number of times DBops.ScanAll should be invoked
func (mmScanAll *mPostgresDBMockScanAll) Times(n uint64) *mPostgresDBMockScanAll {
	if n == 0 {
		mmScanAll.mock.t.Fatalf("Times of PostgresDBMock.ScanAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScanAll.expectedInvocations, n)
	mmScanAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScanAll
}

func (mmScanAll *mPostgresDBMockScanAll) invocationsDone() bool {
	if len(mmScanAll.expectations) == 0 && mmScanAll.defaultExpectation == nil && mmScanAll.mock.funcScanAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScanAll.mock.afterScanAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScanAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScanAll implements mm_dbpostgres.DBops
func (mmScanAll *PostgresDBMock) ScanAll(dst interface{}, rows pgx.Rows) (err error) {
	mm_atomic.AddUint64(&mmScanAll.beforeScanAllCounter, 1)
	defer mm_atomic.AddUint64(&mmScanAll.afterScanAllCounter, 1)

	mmScanAll.t.Helper()

	if mmScanAll.inspectFuncScanAll != nil {
		mmScanAll.inspectFuncScanAll(dst, rows)
	}

	mm_params := PostgresDBMockScanAllParams{dst, rows}

	// Record call args
	mmScanAll.ScanAllMock.mutex.Lock()
	mmScanAll.ScanAllMock.callArgs = append(mmScanAll.ScanAllMock.callArgs, &mm_params)
	mmScanAll.ScanAllMock.mutex.Unlock()

	for _, e := range mmScanAll.ScanAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanAll.ScanAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanAll.ScanAllMock.defaultExpectation.Counter, 1)
		mm_want := mmScanAll.ScanAllMock.defaultExpectation.params
		mm_want_ptrs := mmScanAll.ScanAllMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockScanAllParams{dst, rows}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.dst != nil && !minimock.Equal(*mm_want_ptrs.dst, mm_got.dst) {
				mmScanAll.t.Errorf("PostgresDBMock.ScanAll got unexpected parameter dst, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAll.ScanAllMock.defaultExpectation.expectationOrigins.originDst, *mm_want_ptrs.dst, mm_got.dst, minimock.Diff(*mm_want_ptrs.dst, mm_got.dst))
			}

			if mm_want_ptrs.rows != nil && !minimock.Equal(*mm_want_ptrs.rows, mm_got.rows) {
				mmScanAll.t.Errorf("PostgresDBMock.ScanAll got unexpected parameter rows, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanAll.ScanAllMock.defaultExpectation.expectationOrigins.originRows, *mm_want_ptrs.rows, mm_got.rows, minimock.Diff(*mm_want_ptrs.rows, mm_got.rows))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanAll.t.Errorf("PostgresDBMock.ScanAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScanAll.ScanAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanAll.ScanAllMock.defaultExpectation.results
		if mm_results == nil {
			mmScanAll.t.Fatal("No results are set for the PostgresDBMock.ScanAll")
		}
		return (*mm_results).err
	}
	if mmScanAll.funcScanAll != nil {
		return mmScanAll.funcScanAll(dst, rows)
	}
	mmScanAll.t.Fatalf("Unexpected call to PostgresDBMock.ScanAll. %v %v", dst, rows)
	return
}

// ScanAllAfterCounter returns a count of finished PostgresDBMock.ScanAll invocations
func (mmScanAll *PostgresDBMock) ScanAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAll.afterScanAllCounter)
}

// ScanAllBeforeCounter returns a count of PostgresDBMock.ScanAll invocations
func (mmScanAll *PostgresDBMock) ScanAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAll.beforeScanAllCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.ScanAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanAll *mPostgresDBMockScanAll) Calls() []*PostgresDBMockScanAllParams {
	mmScanAll.mutex.RLock()

	argCopy := make([]*PostgresDBMockScanAllParams, len(mmScanAll.callArgs))
	copy(argCopy, mmScanAll.callArgs)

	mmScanAll.mutex.RUnlock()

	return argCopy
}

// MinimockScanAllDone returns true if the count of the ScanAll invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockScanAllDone() bool {
	if m.ScanAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanAllMock.invocationsDone()
}

// MinimockScanAllInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockScanAllInspect() {
	for _, e := range m.ScanAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.ScanAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanAllCounter := mm_atomic.LoadUint64(&m.afterScanAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllMock.defaultExpectation != nil && afterScanAllCounter < 1 {
		if m.ScanAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.ScanAll at\n%s", m.ScanAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.ScanAll at\n%s with params: %#v", m.ScanAllMock.defaultExpectation.expectationOrigins.origin, *m.ScanAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAll != nil && afterScanAllCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.ScanAll at\n%s", m.funcScanAllOrigin)
	}

	if !m.ScanAllMock.invocationsDone() && afterScanAllCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.ScanAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanAllMock.expectedInvocations), m.ScanAllMock.expectedInvocationsOrigin, afterScanAllCounter)
	}
}

type mPostgresDBMockSelect struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockSelectExpectation
	expectations       []*PostgresDBMockSelectExpectation

	callArgs []*PostgresDBMockSelectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockSelectExpectation specifies expectation struct of the DBops.Select
type PostgresDBMockSelectExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockSelectParams
	paramPtrs          *PostgresDBMockSelectParamPtrs
	expectationOrigins PostgresDBMockSelectExpectationOrigins
	results            *PostgresDBMockSelectResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockSelectParams contains parameters of the DBops.Select
type PostgresDBMockSelectParams struct {
	ctx   context.Context
	dest  interface{}
	query string
	args  []interface{}
}

// PostgresDBMockSelectParamPtrs contains pointers to parameters of the DBops.Select
type PostgresDBMockSelectParamPtrs struct {
	ctx   *context.Context
	dest  *interface{}
	query *string
	args  *[]interface{}
}

// PostgresDBMockSelectResults contains results of the DBops.Select
type PostgresDBMockSelectResults struct {
	err error
}

// PostgresDBMockSelectOrigins contains origins of expectations of the DBops.Select
type PostgresDBMockSelectExpectationOrigins struct {
	origin      string
	originCtx   string
	originDest  string
	originQuery string
	originArgs  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelect *mPostgresDBMockSelect) Optional() *mPostgresDBMockSelect {
	mmSelect.optional = true
	return mmSelect
}

// Expect sets up expected params for DBops.Select
func (mmSelect *mPostgresDBMockSelect) Expect(ctx context.Context, dest interface{}, query string, args ...interface{}) *mPostgresDBMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresDBMockSelectExpectation{}
	}

	if mmSelect.defaultExpectation.paramPtrs != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by ExpectParams functions")
	}

	mmSelect.defaultExpectation.params = &PostgresDBMockSelectParams{ctx, dest, query, args}
	mmSelect.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelect.expectations {
		if minimock.Equal(e.params, mmSelect.defaultExpectation.params) {
			mmSelect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelect.defaultExpectation.params)
		}
	}

	return mmSelect
}

// ExpectCtxParam1 sets up expected param ctx for DBops.Select
func (mmSelect *mPostgresDBMockSelect) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresDBMockSelectExpectation{}
	}

	if mmSelect.defaultExpectation.params != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Expect")
	}

	if mmSelect.defaultExpectation.paramPtrs == nil {
		mmSelect.defaultExpectation.paramPtrs = &PostgresDBMockSelectParamPtrs{}
	}
	mmSelect.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelect.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelect
}

// ExpectDestParam2 sets up expected param dest for DBops.Select
func (mmSelect *mPostgresDBMockSelect) ExpectDestParam2(dest interface{}) *mPostgresDBMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresDBMockSelectExpectation{}
	}

	if mmSelect.defaultExpectation.params != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Expect")
	}

	if mmSelect.defaultExpectation.paramPtrs == nil {
		mmSelect.defaultExpectation.paramPtrs = &PostgresDBMockSelectParamPtrs{}
	}
	mmSelect.defaultExpectation.paramPtrs.dest = &dest
	mmSelect.defaultExpectation.expectationOrigins.originDest = minimock.CallerInfo(1)

	return mmSelect
}

// ExpectQueryParam3 sets up expected param query for DBops.Select
func (mmSelect *mPostgresDBMockSelect) ExpectQueryParam3(query string) *mPostgresDBMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresDBMockSelectExpectation{}
	}

	if mmSelect.defaultExpectation.params != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Expect")
	}

	if mmSelect.defaultExpectation.paramPtrs == nil {
		mmSelect.defaultExpectation.paramPtrs = &PostgresDBMockSelectParamPtrs{}
	}
	mmSelect.defaultExpectation.paramPtrs.query = &query
	mmSelect.defaultExpectation.expectationOrigins.originQuery = minimock.CallerInfo(1)

	return mmSelect
}

// ExpectArgsParam4 sets up expected param args for DBops.Select
func (mmSelect *mPostgresDBMockSelect) ExpectArgsParam4(args ...interface{}) *mPostgresDBMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresDBMockSelectExpectation{}
	}

	if mmSelect.defaultExpectation.params != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Expect")
	}

	if mmSelect.defaultExpectation.paramPtrs == nil {
		mmSelect.defaultExpectation.paramPtrs = &PostgresDBMockSelectParamPtrs{}
	}
	mmSelect.defaultExpectation.paramPtrs.args = &args
	mmSelect.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmSelect
}

// Inspect accepts an inspector function that has same arguments as the DBops.Select
func (mmSelect *mPostgresDBMockSelect) Inspect(f func(ctx context.Context, dest interface{}, query string, args ...interface{})) *mPostgresDBMockSelect {
	if mmSelect.mock.inspectFuncSelect != nil {
		mmSelect.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.Select")
	}

	mmSelect.mock.inspectFuncSelect = f

	return mmSelect
}

// Return sets up results that will be returned by DBops.Select
func (mmSelect *mPostgresDBMockSelect) Return(err error) *PostgresDBMock {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresDBMockSelectExpectation{mock: mmSelect.mock}
	}
	mmSelect.defaultExpectation.results = &PostgresDBMockSelectResults{err}
	mmSelect.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelect.mock
}

// Set uses given function f to mock the DBops.Select method
func (mmSelect *mPostgresDBMockSelect) Set(f func(ctx context.Context, dest interface{}, query string, args ...interface{}) (err error)) *PostgresDBMock {
	if mmSelect.defaultExpectation != nil {
		mmSelect.mock.t.Fatalf("Default expectation is already set for the DBops.Select method")
	}

	if len(mmSelect.expectations) > 0 {
		mmSelect.mock.t.Fatalf("Some expectations are already set for the DBops.Select method")
	}

	mmSelect.mock.funcSelect = f
	mmSelect.mock.funcSelectOrigin = minimock.CallerInfo(1)
	return mmSelect.mock
}

// When sets expectation for the DBops.Select which will trigger the result defined by the following
// Then helper
func (mmSelect *mPostgresDBMockSelect) When(ctx context.Context, dest interface{}, query string, args ...interface{}) *PostgresDBMockSelectExpectation {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresDBMock.Select mock is already set by Set")
	}

	expectation := &PostgresDBMockSelectExpectation{
		mock:               mmSelect.mock,
		params:             &PostgresDBMockSelectParams{ctx, dest, query, args},
		expectationOrigins: PostgresDBMockSelectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelect.expectations = append(mmSelect.expectations, expectation)
	return expectation
}

// Then sets up DBops.Select return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockSelectExpectation) Then(err error) *PostgresDBMock {
	e.results = &PostgresDBMockSelectResults{err}
	return e.mock
}

// Times sets number of times DBops.Select should be invoked
func (mmSelect *mPostgresDBMockSelect) Times(n uint64) *mPostgresDBMockSelect {
	if n == 0 {
		mmSelect.mock.t.Fatalf("Times of PostgresDBMock.Select mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelect.expectedInvocations, n)
	mmSelect.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelect
}

func (mmSelect *mPostgresDBMockSelect) invocationsDone() bool {
	if len(mmSelect.expectations) == 0 && mmSelect.defaultExpectation == nil && mmSelect.mock.funcSelect == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelect.mock.afterSelectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelect.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Select implements mm_dbpostgres.DBops
func (mmSelect *PostgresDBMock) Select(ctx context.Context, dest interface{}, query string, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmSelect.beforeSelectCounter, 1)
	defer mm_atomic.AddUint64(&mmSelect.afterSelectCounter, 1)

	mmSelect.t.Helper()

	if mmSelect.inspectFuncSelect != nil {
		mmSelect.inspectFuncSelect(ctx, dest, query, args...)
	}

	mm_params := PostgresDBMockSelectParams{ctx, dest, query, args}

	// Record call args
	mmSelect.SelectMock.mutex.Lock()
	mmSelect.SelectMock.callArgs = append(mmSelect.SelectMock.callArgs, &mm_params)
	mmSelect.SelectMock.mutex.Unlock()

	for _, e := range mmSelect.SelectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelect.SelectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelect.SelectMock.defaultExpectation.Counter, 1)
		mm_want := mmSelect.SelectMock.defaultExpectation.params
		mm_want_ptrs := mmSelect.SelectMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockSelectParams{ctx, dest, query, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelect.t.Errorf("PostgresDBMock.Select got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelect.SelectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dest != nil && !minimock.Equal(*mm_want_ptrs.dest, mm_got.dest) {
				mmSelect.t.Errorf("PostgresDBMock.Select got unexpected parameter dest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelect.SelectMock.defaultExpectation.expectationOrigins.originDest, *mm_want_ptrs.dest, mm_got.dest, minimock.Diff(*mm_want_ptrs.dest, mm_got.dest))
			}

			if mm_want_ptrs.query != nil && !minimock.Equal(*mm_want_ptrs.query, mm_got.query) {
				mmSelect.t.Errorf("PostgresDBMock.Select got unexpected parameter query, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelect.SelectMock.defaultExpectation.expectationOrigins.originQuery, *mm_want_ptrs.query, mm_got.query, minimock.Diff(*mm_want_ptrs.query, mm_got.query))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmSelect.t.Errorf("PostgresDBMock.Select got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelect.SelectMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelect.t.Errorf("PostgresDBMock.Select got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelect.SelectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelect.SelectMock.defaultExpectation.results
		if mm_results == nil {
			mmSelect.t.Fatal("No results are set for the PostgresDBMock.Select")
		}
		return (*mm_results).err
	}
	if mmSelect.funcSelect != nil {
		return mmSelect.funcSelect(ctx, dest, query, args...)
	}
	mmSelect.t.Fatalf("Unexpected call to PostgresDBMock.Select. %v %v %v %v", ctx, dest, query, args)
	return
}

// SelectAfterCounter returns a count of finished PostgresDBMock.Select invocations
func (mmSelect *PostgresDBMock) SelectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelect.afterSelectCounter)
}

// SelectBeforeCounter returns a count of PostgresDBMock.Select invocations
func (mmSelect *PostgresDBMock) SelectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelect.beforeSelectCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.Select.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelect *mPostgresDBMockSelect) Calls() []*PostgresDBMockSelectParams {
	mmSelect.mutex.RLock()

	argCopy := make([]*PostgresDBMockSelectParams, len(mmSelect.callArgs))
	copy(argCopy, mmSelect.callArgs)

	mmSelect.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDone returns true if the count of the Select invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockSelectDone() bool {
	if m.SelectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectMock.invocationsDone()
}

// MinimockSelectInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockSelectInspect() {
	for _, e := range m.SelectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.Select at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectCounter := mm_atomic.LoadUint64(&m.afterSelectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectMock.defaultExpectation != nil && afterSelectCounter < 1 {
		if m.SelectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.Select at\n%s", m.SelectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.Select at\n%s with params: %#v", m.SelectMock.defaultExpectation.expectationOrigins.origin, *m.SelectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelect != nil && afterSelectCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.Select at\n%s", m.funcSelectOrigin)
	}

	if !m.SelectMock.invocationsDone() && afterSelectCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.Select at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectMock.expectedInvocations), m.SelectMock.expectedInvocationsOrigin, afterSelectCounter)
	}
}

type mPostgresDBMockTxBegin struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockTxBeginExpectation
	expectations       []*PostgresDBMockTxBeginExpectation

	callArgs []*PostgresDBMockTxBeginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockTxBeginExpectation specifies expectation struct of the DBops.TxBegin
type PostgresDBMockTxBeginExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockTxBeginParams
	paramPtrs          *PostgresDBMockTxBeginParamPtrs
	expectationOrigins PostgresDBMockTxBeginExpectationOrigins
	results            *PostgresDBMockTxBeginResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockTxBeginParams contains parameters of the DBops.TxBegin
type PostgresDBMockTxBeginParams struct {
	ctx context.Context
}

// PostgresDBMockTxBeginParamPtrs contains pointers to parameters of the DBops.TxBegin
type PostgresDBMockTxBeginParamPtrs struct {
	ctx *context.Context
}

// PostgresDBMockTxBeginResults contains results of the DBops.TxBegin
type PostgresDBMockTxBeginResults struct {
	t1  pgx.Tx
	err error
}

// PostgresDBMockTxBeginOrigins contains origins of expectations of the DBops.TxBegin
type PostgresDBMockTxBeginExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTxBegin *mPostgresDBMockTxBegin) Optional() *mPostgresDBMockTxBegin {
	mmTxBegin.optional = true
	return mmTxBegin
}

// Expect sets up expected params for DBops.TxBegin
func (mmTxBegin *mPostgresDBMockTxBegin) Expect(ctx context.Context) *mPostgresDBMockTxBegin {
	if mmTxBegin.mock.funcTxBegin != nil {
		mmTxBegin.mock.t.Fatalf("PostgresDBMock.TxBegin mock is already set by Set")
	}

	if mmTxBegin.defaultExpectation == nil {
		mmTxBegin.defaultExpectation = &PostgresDBMockTxBeginExpectation{}
	}

	if mmTxBegin.defaultExpectation.paramPtrs != nil {
		mmTxBegin.mock.t.Fatalf("PostgresDBMock.TxBegin mock is already set by ExpectParams functions")
	}

	mmTxBegin.defaultExpectation.params = &PostgresDBMockTxBeginParams{ctx}
	mmTxBegin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTxBegin.expectations {
		if minimock.Equal(e.params, mmTxBegin.defaultExpectation.params) {
			mmTxBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTxBegin.defaultExpectation.params)
		}
	}

	return mmTxBegin
}

// ExpectCtxParam1 sets up expected param ctx for DBops.TxBegin
func (mmTxBegin *mPostgresDBMockTxBegin) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockTxBegin {
	if mmTxBegin.mock.funcTxBegin != nil {
		mmTxBegin.mock.t.Fatalf("PostgresDBMock.TxBegin mock is already set by Set")
	}

	if mmTxBegin.defaultExpectation == nil {
		mmTxBegin.defaultExpectation = &PostgresDBMockTxBeginExpectation{}
	}

	if mmTxBegin.defaultExpectation.params != nil {
		mmTxBegin.mock.t.Fatalf("PostgresDBMock.TxBegin mock is already set by Expect")
	}

	if mmTxBegin.defaultExpectation.paramPtrs == nil {
		mmTxBegin.defaultExpectation.paramPtrs = &PostgresDBMockTxBeginParamPtrs{}
	}
	mmTxBegin.defaultExpectation.paramPtrs.ctx = &ctx
	mmTxBegin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTxBegin
}

// Inspect accepts an inspector function that has same arguments as the DBops.TxBegin
func (mmTxBegin *mPostgresDBMockTxBegin) Inspect(f func(ctx context.Context)) *mPostgresDBMockTxBegin {
	if mmTxBegin.mock.inspectFuncTxBegin != nil {
		mmTxBegin.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.TxBegin")
	}

	mmTxBegin.mock.inspectFuncTxBegin = f

	return mmTxBegin
}

// Return sets up results that will be returned by DBops.TxBegin
func (mmTxBegin *mPostgresDBMockTxBegin) Return(t1 pgx.Tx, err error) *PostgresDBMock {
	if mmTxBegin.mock.funcTxBegin != nil {
		mmTxBegin.mock.t.Fatalf("PostgresDBMock.TxBegin mock is already set by Set")
	}

	if mmTxBegin.defaultExpectation == nil {
		mmTxBegin.defaultExpectation = &PostgresDBMockTxBeginExpectation{mock: mmTxBegin.mock}
	}
	mmTxBegin.defaultExpectation.results = &PostgresDBMockTxBeginResults{t1, err}
	mmTxBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTxBegin.mock
}

// Set uses given function f to mock the DBops.TxBegin method
func (mmTxBegin *mPostgresDBMockTxBegin) Set(f func(ctx context.Context) (t1 pgx.Tx, err error)) *PostgresDBMock {
	if mmTxBegin.defaultExpectation != nil {
		mmTxBegin.mock.t.Fatalf("Default expectation is already set for the DBops.TxBegin method")
	}

	if len(mmTxBegin.expectations) > 0 {
		mmTxBegin.mock.t.Fatalf("Some expectations are already set for the DBops.TxBegin method")
	}

	mmTxBegin.mock.funcTxBegin = f
	mmTxBegin.mock.funcTxBeginOrigin = minimock.CallerInfo(1)
	return mmTxBegin.mock
}

// When sets expectation for the DBops.TxBegin which will trigger the result defined by the following
// Then helper
func (mmTxBegin *mPostgresDBMockTxBegin) When(ctx context.Context) *PostgresDBMockTxBeginExpectation {
	if mmTxBegin.mock.funcTxBegin != nil {
		mmTxBegin.mock.t.Fatalf("PostgresDBMock.TxBegin mock is already set by Set")
	}

	expectation := &PostgresDBMockTxBeginExpectation{
		mock:               mmTxBegin.mock,
		params:             &PostgresDBMockTxBeginParams{ctx},
		expectationOrigins: PostgresDBMockTxBeginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTxBegin.expectations = append(mmTxBegin.expectations, expectation)
	return expectation
}

// Then sets up DBops.TxBegin return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockTxBeginExpectation) Then(t1 pgx.Tx, err error) *PostgresDBMock {
	e.results = &PostgresDBMockTxBeginResults{t1, err}
	return e.mock
}

// Times sets number of times DBops.TxBegin should be invoked
func (mmTxBegin *mPostgresDBMockTxBegin) Times(n uint64) *mPostgresDBMockTxBegin {
	if n == 0 {
		mmTxBegin.mock.t.Fatalf("Times of PostgresDBMock.TxBegin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTxBegin.expectedInvocations, n)
	mmTxBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTxBegin
}

func (mmTxBegin *mPostgresDBMockTxBegin) invocationsDone() bool {
	if len(mmTxBegin.expectations) == 0 && mmTxBegin.defaultExpectation == nil && mmTxBegin.mock.funcTxBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTxBegin.mock.afterTxBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTxBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TxBegin implements mm_dbpostgres.DBops
func (mmTxBegin *PostgresDBMock) TxBegin(ctx context.Context) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmTxBegin.beforeTxBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmTxBegin.afterTxBeginCounter, 1)

	mmTxBegin.t.Helper()

	if mmTxBegin.inspectFuncTxBegin != nil {
		mmTxBegin.inspectFuncTxBegin(ctx)
	}

	mm_params := PostgresDBMockTxBeginParams{ctx}

	// Record call args
	mmTxBegin.TxBeginMock.mutex.Lock()
	mmTxBegin.TxBeginMock.callArgs = append(mmTxBegin.TxBeginMock.callArgs, &mm_params)
	mmTxBegin.TxBeginMock.mutex.Unlock()

	for _, e := range mmTxBegin.TxBeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmTxBegin.TxBeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxBegin.TxBeginMock.defaultExpectation.Counter, 1)
		mm_want := mmTxBegin.TxBeginMock.defaultExpectation.params
		mm_want_ptrs := mmTxBegin.TxBeginMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockTxBeginParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTxBegin.t.Errorf("PostgresDBMock.TxBegin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxBegin.TxBeginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTxBegin.t.Errorf("PostgresDBMock.TxBegin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTxBegin.TxBeginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTxBegin.TxBeginMock.defaultExpectation.results
		if mm_results == nil {
			mmTxBegin.t.Fatal("No results are set for the PostgresDBMock.TxBegin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmTxBegin.funcTxBegin != nil {
		return mmTxBegin.funcTxBegin(ctx)
	}
	mmTxBegin.t.Fatalf("Unexpected call to PostgresDBMock.TxBegin. %v", ctx)
	return
}

// TxBeginAfterCounter returns a count of finished PostgresDBMock.TxBegin invocations
func (mmTxBegin *PostgresDBMock) TxBeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxBegin.afterTxBeginCounter)
}

// TxBeginBeforeCounter returns a count of PostgresDBMock.TxBegin invocations
func (mmTxBegin *PostgresDBMock) TxBeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxBegin.beforeTxBeginCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.TxBegin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTxBegin *mPostgresDBMockTxBegin) Calls() []*PostgresDBMockTxBeginParams {
	mmTxBegin.mutex.RLock()

	argCopy := make([]*PostgresDBMockTxBeginParams, len(mmTxBegin.callArgs))
	copy(argCopy, mmTxBegin.callArgs)

	mmTxBegin.mutex.RUnlock()

	return argCopy
}

// MinimockTxBeginDone returns true if the count of the TxBegin invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockTxBeginDone() bool {
	if m.TxBeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TxBeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TxBeginMock.invocationsDone()
}

// MinimockTxBeginInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockTxBeginInspect() {
	for _, e := range m.TxBeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.TxBegin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTxBeginCounter := mm_atomic.LoadUint64(&m.afterTxBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TxBeginMock.defaultExpectation != nil && afterTxBeginCounter < 1 {
		if m.TxBeginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.TxBegin at\n%s", m.TxBeginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.TxBegin at\n%s with params: %#v", m.TxBeginMock.defaultExpectation.expectationOrigins.origin, *m.TxBeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxBegin != nil && afterTxBeginCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.TxBegin at\n%s", m.funcTxBeginOrigin)
	}

	if !m.TxBeginMock.invocationsDone() && afterTxBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.TxBegin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TxBeginMock.expectedInvocations), m.TxBeginMock.expectedInvocationsOrigin, afterTxBeginCounter)
	}
}

type mPostgresDBMockTxExec struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockTxExecExpectation
	expectations       []*PostgresDBMockTxExecExpectation

	callArgs []*PostgresDBMockTxExecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockTxExecExpectation specifies expectation struct of the DBops.TxExec
type PostgresDBMockTxExecExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockTxExecParams
	paramPtrs          *PostgresDBMockTxExecParamPtrs
	expectationOrigins PostgresDBMockTxExecExpectationOrigins
	results            *PostgresDBMockTxExecResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockTxExecParams contains parameters of the DBops.TxExec
type PostgresDBMockTxExecParams struct {
	ctx  context.Context
	tx   pgx.Tx
	sql  string
	args []interface{}
}

// PostgresDBMockTxExecParamPtrs contains pointers to parameters of the DBops.TxExec
type PostgresDBMockTxExecParamPtrs struct {
	ctx  *context.Context
	tx   *pgx.Tx
	sql  *string
	args *[]interface{}
}

// PostgresDBMockTxExecResults contains results of the DBops.TxExec
type PostgresDBMockTxExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// PostgresDBMockTxExecOrigins contains origins of expectations of the DBops.TxExec
type PostgresDBMockTxExecExpectationOrigins struct {
	origin     string
	originCtx  string
	originTx   string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTxExec *mPostgresDBMockTxExec) Optional() *mPostgresDBMockTxExec {
	mmTxExec.optional = true
	return mmTxExec
}

// Expect sets up expected params for DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) Expect(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) *mPostgresDBMockTxExec {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	if mmTxExec.defaultExpectation == nil {
		mmTxExec.defaultExpectation = &PostgresDBMockTxExecExpectation{}
	}

	if mmTxExec.defaultExpectation.paramPtrs != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by ExpectParams functions")
	}

	mmTxExec.defaultExpectation.params = &PostgresDBMockTxExecParams{ctx, tx, sql, args}
	mmTxExec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTxExec.expectations {
		if minimock.Equal(e.params, mmTxExec.defaultExpectation.params) {
			mmTxExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTxExec.defaultExpectation.params)
		}
	}

	return mmTxExec
}

// ExpectCtxParam1 sets up expected param ctx for DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockTxExec {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	if mmTxExec.defaultExpectation == nil {
		mmTxExec.defaultExpectation = &PostgresDBMockTxExecExpectation{}
	}

	if mmTxExec.defaultExpectation.params != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Expect")
	}

	if mmTxExec.defaultExpectation.paramPtrs == nil {
		mmTxExec.defaultExpectation.paramPtrs = &PostgresDBMockTxExecParamPtrs{}
	}
	mmTxExec.defaultExpectation.paramPtrs.ctx = &ctx
	mmTxExec.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTxExec
}

// ExpectTxParam2 sets up expected param tx for DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) ExpectTxParam2(tx pgx.Tx) *mPostgresDBMockTxExec {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	if mmTxExec.defaultExpectation == nil {
		mmTxExec.defaultExpectation = &PostgresDBMockTxExecExpectation{}
	}

	if mmTxExec.defaultExpectation.params != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Expect")
	}

	if mmTxExec.defaultExpectation.paramPtrs == nil {
		mmTxExec.defaultExpectation.paramPtrs = &PostgresDBMockTxExecParamPtrs{}
	}
	mmTxExec.defaultExpectation.paramPtrs.tx = &tx
	mmTxExec.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmTxExec
}

// ExpectSqlParam3 sets up expected param sql for DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) ExpectSqlParam3(sql string) *mPostgresDBMockTxExec {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	if mmTxExec.defaultExpectation == nil {
		mmTxExec.defaultExpectation = &PostgresDBMockTxExecExpectation{}
	}

	if mmTxExec.defaultExpectation.params != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Expect")
	}

	if mmTxExec.defaultExpectation.paramPtrs == nil {
		mmTxExec.defaultExpectation.paramPtrs = &PostgresDBMockTxExecParamPtrs{}
	}
	mmTxExec.defaultExpectation.paramPtrs.sql = &sql
	mmTxExec.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmTxExec
}

// ExpectArgsParam4 sets up expected param args for DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) ExpectArgsParam4(args ...interface{}) *mPostgresDBMockTxExec {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	if mmTxExec.defaultExpectation == nil {
		mmTxExec.defaultExpectation = &PostgresDBMockTxExecExpectation{}
	}

	if mmTxExec.defaultExpectation.params != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Expect")
	}

	if mmTxExec.defaultExpectation.paramPtrs == nil {
		mmTxExec.defaultExpectation.paramPtrs = &PostgresDBMockTxExecParamPtrs{}
	}
	mmTxExec.defaultExpectation.paramPtrs.args = &args
	mmTxExec.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmTxExec
}

// Inspect accepts an inspector function that has same arguments as the DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) Inspect(f func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{})) *mPostgresDBMockTxExec {
	if mmTxExec.mock.inspectFuncTxExec != nil {
		mmTxExec.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.TxExec")
	}

	mmTxExec.mock.inspectFuncTxExec = f

	return mmTxExec
}

// Return sets up results that will be returned by DBops.TxExec
func (mmTxExec *mPostgresDBMockTxExec) Return(commandTag pgconn.CommandTag, err error) *PostgresDBMock {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	if mmTxExec.defaultExpectation == nil {
		mmTxExec.defaultExpectation = &PostgresDBMockTxExecExpectation{mock: mmTxExec.mock}
	}
	mmTxExec.defaultExpectation.results = &PostgresDBMockTxExecResults{commandTag, err}
	mmTxExec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTxExec.mock
}

// Set uses given function f to mock the DBops.TxExec method
func (mmTxExec *mPostgresDBMockTxExec) Set(f func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) (commandTag pgconn.CommandTag, err error)) *PostgresDBMock {
	if mmTxExec.defaultExpectation != nil {
		mmTxExec.mock.t.Fatalf("Default expectation is already set for the DBops.TxExec method")
	}

	if len(mmTxExec.expectations) > 0 {
		mmTxExec.mock.t.Fatalf("Some expectations are already set for the DBops.TxExec method")
	}

	mmTxExec.mock.funcTxExec = f
	mmTxExec.mock.funcTxExecOrigin = minimock.CallerInfo(1)
	return mmTxExec.mock
}

// When sets expectation for the DBops.TxExec which will trigger the result defined by the following
// Then helper
func (mmTxExec *mPostgresDBMockTxExec) When(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) *PostgresDBMockTxExecExpectation {
	if mmTxExec.mock.funcTxExec != nil {
		mmTxExec.mock.t.Fatalf("PostgresDBMock.TxExec mock is already set by Set")
	}

	expectation := &PostgresDBMockTxExecExpectation{
		mock:               mmTxExec.mock,
		params:             &PostgresDBMockTxExecParams{ctx, tx, sql, args},
		expectationOrigins: PostgresDBMockTxExecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTxExec.expectations = append(mmTxExec.expectations, expectation)
	return expectation
}

// Then sets up DBops.TxExec return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockTxExecExpectation) Then(commandTag pgconn.CommandTag, err error) *PostgresDBMock {
	e.results = &PostgresDBMockTxExecResults{commandTag, err}
	return e.mock
}

// Times sets number of times DBops.TxExec should be invoked
func (mmTxExec *mPostgresDBMockTxExec) Times(n uint64) *mPostgresDBMockTxExec {
	if n == 0 {
		mmTxExec.mock.t.Fatalf("Times of PostgresDBMock.TxExec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTxExec.expectedInvocations, n)
	mmTxExec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTxExec
}

func (mmTxExec *mPostgresDBMockTxExec) invocationsDone() bool {
	if len(mmTxExec.expectations) == 0 && mmTxExec.defaultExpectation == nil && mmTxExec.mock.funcTxExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTxExec.mock.afterTxExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTxExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TxExec implements mm_dbpostgres.DBops
func (mmTxExec *PostgresDBMock) TxExec(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmTxExec.beforeTxExecCounter, 1)
	defer mm_atomic.AddUint64(&mmTxExec.afterTxExecCounter, 1)

	mmTxExec.t.Helper()

	if mmTxExec.inspectFuncTxExec != nil {
		mmTxExec.inspectFuncTxExec(ctx, tx, sql, args...)
	}

	mm_params := PostgresDBMockTxExecParams{ctx, tx, sql, args}

	// Record call args
	mmTxExec.TxExecMock.mutex.Lock()
	mmTxExec.TxExecMock.callArgs = append(mmTxExec.TxExecMock.callArgs, &mm_params)
	mmTxExec.TxExecMock.mutex.Unlock()

	for _, e := range mmTxExec.TxExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmTxExec.TxExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxExec.TxExecMock.defaultExpectation.Counter, 1)
		mm_want := mmTxExec.TxExecMock.defaultExpectation.params
		mm_want_ptrs := mmTxExec.TxExecMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockTxExecParams{ctx, tx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTxExec.t.Errorf("PostgresDBMock.TxExec got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxExec.TxExecMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmTxExec.t.Errorf("PostgresDBMock.TxExec got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxExec.TxExecMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmTxExec.t.Errorf("PostgresDBMock.TxExec got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxExec.TxExecMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmTxExec.t.Errorf("PostgresDBMock.TxExec got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxExec.TxExecMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTxExec.t.Errorf("PostgresDBMock.TxExec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTxExec.TxExecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTxExec.TxExecMock.defaultExpectation.results
		if mm_results == nil {
			mmTxExec.t.Fatal("No results are set for the PostgresDBMock.TxExec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmTxExec.funcTxExec != nil {
		return mmTxExec.funcTxExec(ctx, tx, sql, args...)
	}
	mmTxExec.t.Fatalf("Unexpected call to PostgresDBMock.TxExec. %v %v %v %v", ctx, tx, sql, args)
	return
}

// TxExecAfterCounter returns a count of finished PostgresDBMock.TxExec invocations
func (mmTxExec *PostgresDBMock) TxExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxExec.afterTxExecCounter)
}

// TxExecBeforeCounter returns a count of PostgresDBMock.TxExec invocations
func (mmTxExec *PostgresDBMock) TxExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxExec.beforeTxExecCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.TxExec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTxExec *mPostgresDBMockTxExec) Calls() []*PostgresDBMockTxExecParams {
	mmTxExec.mutex.RLock()

	argCopy := make([]*PostgresDBMockTxExecParams, len(mmTxExec.callArgs))
	copy(argCopy, mmTxExec.callArgs)

	mmTxExec.mutex.RUnlock()

	return argCopy
}

// MinimockTxExecDone returns true if the count of the TxExec invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockTxExecDone() bool {
	if m.TxExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TxExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TxExecMock.invocationsDone()
}

// MinimockTxExecInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockTxExecInspect() {
	for _, e := range m.TxExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.TxExec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTxExecCounter := mm_atomic.LoadUint64(&m.afterTxExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TxExecMock.defaultExpectation != nil && afterTxExecCounter < 1 {
		if m.TxExecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.TxExec at\n%s", m.TxExecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.TxExec at\n%s with params: %#v", m.TxExecMock.defaultExpectation.expectationOrigins.origin, *m.TxExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxExec != nil && afterTxExecCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.TxExec at\n%s", m.funcTxExecOrigin)
	}

	if !m.TxExecMock.invocationsDone() && afterTxExecCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.TxExec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TxExecMock.expectedInvocations), m.TxExecMock.expectedInvocationsOrigin, afterTxExecCounter)
	}
}

type mPostgresDBMockTxQuery struct {
	optional           bool
	mock               *PostgresDBMock
	defaultExpectation *PostgresDBMockTxQueryExpectation
	expectations       []*PostgresDBMockTxQueryExpectation

	callArgs []*PostgresDBMockTxQueryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresDBMockTxQueryExpectation specifies expectation struct of the DBops.TxQuery
type PostgresDBMockTxQueryExpectation struct {
	mock               *PostgresDBMock
	params             *PostgresDBMockTxQueryParams
	paramPtrs          *PostgresDBMockTxQueryParamPtrs
	expectationOrigins PostgresDBMockTxQueryExpectationOrigins
	results            *PostgresDBMockTxQueryResults
	returnOrigin       string
	Counter            uint64
}

// PostgresDBMockTxQueryParams contains parameters of the DBops.TxQuery
type PostgresDBMockTxQueryParams struct {
	ctx  context.Context
	tx   pgx.Tx
	sql  string
	args []interface{}
}

// PostgresDBMockTxQueryParamPtrs contains pointers to parameters of the DBops.TxQuery
type PostgresDBMockTxQueryParamPtrs struct {
	ctx  *context.Context
	tx   *pgx.Tx
	sql  *string
	args *[]interface{}
}

// PostgresDBMockTxQueryResults contains results of the DBops.TxQuery
type PostgresDBMockTxQueryResults struct {
	r1  pgx.Rows
	err error
}

// PostgresDBMockTxQueryOrigins contains origins of expectations of the DBops.TxQuery
type PostgresDBMockTxQueryExpectationOrigins struct {
	origin     string
	originCtx  string
	originTx   string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTxQuery *mPostgresDBMockTxQuery) Optional() *mPostgresDBMockTxQuery {
	mmTxQuery.optional = true
	return mmTxQuery
}

// Expect sets up expected params for DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) Expect(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) *mPostgresDBMockTxQuery {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	if mmTxQuery.defaultExpectation == nil {
		mmTxQuery.defaultExpectation = &PostgresDBMockTxQueryExpectation{}
	}

	if mmTxQuery.defaultExpectation.paramPtrs != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by ExpectParams functions")
	}

	mmTxQuery.defaultExpectation.params = &PostgresDBMockTxQueryParams{ctx, tx, sql, args}
	mmTxQuery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTxQuery.expectations {
		if minimock.Equal(e.params, mmTxQuery.defaultExpectation.params) {
			mmTxQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTxQuery.defaultExpectation.params)
		}
	}

	return mmTxQuery
}

// ExpectCtxParam1 sets up expected param ctx for DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) ExpectCtxParam1(ctx context.Context) *mPostgresDBMockTxQuery {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	if mmTxQuery.defaultExpectation == nil {
		mmTxQuery.defaultExpectation = &PostgresDBMockTxQueryExpectation{}
	}

	if mmTxQuery.defaultExpectation.params != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Expect")
	}

	if mmTxQuery.defaultExpectation.paramPtrs == nil {
		mmTxQuery.defaultExpectation.paramPtrs = &PostgresDBMockTxQueryParamPtrs{}
	}
	mmTxQuery.defaultExpectation.paramPtrs.ctx = &ctx
	mmTxQuery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTxQuery
}

// ExpectTxParam2 sets up expected param tx for DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) ExpectTxParam2(tx pgx.Tx) *mPostgresDBMockTxQuery {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	if mmTxQuery.defaultExpectation == nil {
		mmTxQuery.defaultExpectation = &PostgresDBMockTxQueryExpectation{}
	}

	if mmTxQuery.defaultExpectation.params != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Expect")
	}

	if mmTxQuery.defaultExpectation.paramPtrs == nil {
		mmTxQuery.defaultExpectation.paramPtrs = &PostgresDBMockTxQueryParamPtrs{}
	}
	mmTxQuery.defaultExpectation.paramPtrs.tx = &tx
	mmTxQuery.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmTxQuery
}

// ExpectSqlParam3 sets up expected param sql for DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) ExpectSqlParam3(sql string) *mPostgresDBMockTxQuery {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	if mmTxQuery.defaultExpectation == nil {
		mmTxQuery.defaultExpectation = &PostgresDBMockTxQueryExpectation{}
	}

	if mmTxQuery.defaultExpectation.params != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Expect")
	}

	if mmTxQuery.defaultExpectation.paramPtrs == nil {
		mmTxQuery.defaultExpectation.paramPtrs = &PostgresDBMockTxQueryParamPtrs{}
	}
	mmTxQuery.defaultExpectation.paramPtrs.sql = &sql
	mmTxQuery.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmTxQuery
}

// ExpectArgsParam4 sets up expected param args for DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) ExpectArgsParam4(args ...interface{}) *mPostgresDBMockTxQuery {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	if mmTxQuery.defaultExpectation == nil {
		mmTxQuery.defaultExpectation = &PostgresDBMockTxQueryExpectation{}
	}

	if mmTxQuery.defaultExpectation.params != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Expect")
	}

	if mmTxQuery.defaultExpectation.paramPtrs == nil {
		mmTxQuery.defaultExpectation.paramPtrs = &PostgresDBMockTxQueryParamPtrs{}
	}
	mmTxQuery.defaultExpectation.paramPtrs.args = &args
	mmTxQuery.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmTxQuery
}

// Inspect accepts an inspector function that has same arguments as the DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) Inspect(f func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{})) *mPostgresDBMockTxQuery {
	if mmTxQuery.mock.inspectFuncTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("Inspect function is already set for PostgresDBMock.TxQuery")
	}

	mmTxQuery.mock.inspectFuncTxQuery = f

	return mmTxQuery
}

// Return sets up results that will be returned by DBops.TxQuery
func (mmTxQuery *mPostgresDBMockTxQuery) Return(r1 pgx.Rows, err error) *PostgresDBMock {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	if mmTxQuery.defaultExpectation == nil {
		mmTxQuery.defaultExpectation = &PostgresDBMockTxQueryExpectation{mock: mmTxQuery.mock}
	}
	mmTxQuery.defaultExpectation.results = &PostgresDBMockTxQueryResults{r1, err}
	mmTxQuery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTxQuery.mock
}

// Set uses given function f to mock the DBops.TxQuery method
func (mmTxQuery *mPostgresDBMockTxQuery) Set(f func(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) (r1 pgx.Rows, err error)) *PostgresDBMock {
	if mmTxQuery.defaultExpectation != nil {
		mmTxQuery.mock.t.Fatalf("Default expectation is already set for the DBops.TxQuery method")
	}

	if len(mmTxQuery.expectations) > 0 {
		mmTxQuery.mock.t.Fatalf("Some expectations are already set for the DBops.TxQuery method")
	}

	mmTxQuery.mock.funcTxQuery = f
	mmTxQuery.mock.funcTxQueryOrigin = minimock.CallerInfo(1)
	return mmTxQuery.mock
}

// When sets expectation for the DBops.TxQuery which will trigger the result defined by the following
// Then helper
func (mmTxQuery *mPostgresDBMockTxQuery) When(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) *PostgresDBMockTxQueryExpectation {
	if mmTxQuery.mock.funcTxQuery != nil {
		mmTxQuery.mock.t.Fatalf("PostgresDBMock.TxQuery mock is already set by Set")
	}

	expectation := &PostgresDBMockTxQueryExpectation{
		mock:               mmTxQuery.mock,
		params:             &PostgresDBMockTxQueryParams{ctx, tx, sql, args},
		expectationOrigins: PostgresDBMockTxQueryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTxQuery.expectations = append(mmTxQuery.expectations, expectation)
	return expectation
}

// Then sets up DBops.TxQuery return parameters for the expectation previously defined by the When method
func (e *PostgresDBMockTxQueryExpectation) Then(r1 pgx.Rows, err error) *PostgresDBMock {
	e.results = &PostgresDBMockTxQueryResults{r1, err}
	return e.mock
}

// Times sets number of times DBops.TxQuery should be invoked
func (mmTxQuery *mPostgresDBMockTxQuery) Times(n uint64) *mPostgresDBMockTxQuery {
	if n == 0 {
		mmTxQuery.mock.t.Fatalf("Times of PostgresDBMock.TxQuery mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTxQuery.expectedInvocations, n)
	mmTxQuery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTxQuery
}

func (mmTxQuery *mPostgresDBMockTxQuery) invocationsDone() bool {
	if len(mmTxQuery.expectations) == 0 && mmTxQuery.defaultExpectation == nil && mmTxQuery.mock.funcTxQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTxQuery.mock.afterTxQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTxQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TxQuery implements mm_dbpostgres.DBops
func (mmTxQuery *PostgresDBMock) TxQuery(ctx context.Context, tx pgx.Tx, sql string, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmTxQuery.beforeTxQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmTxQuery.afterTxQueryCounter, 1)

	mmTxQuery.t.Helper()

	if mmTxQuery.inspectFuncTxQuery != nil {
		mmTxQuery.inspectFuncTxQuery(ctx, tx, sql, args...)
	}

	mm_params := PostgresDBMockTxQueryParams{ctx, tx, sql, args}

	// Record call args
	mmTxQuery.TxQueryMock.mutex.Lock()
	mmTxQuery.TxQueryMock.callArgs = append(mmTxQuery.TxQueryMock.callArgs, &mm_params)
	mmTxQuery.TxQueryMock.mutex.Unlock()

	for _, e := range mmTxQuery.TxQueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmTxQuery.TxQueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxQuery.TxQueryMock.defaultExpectation.Counter, 1)
		mm_want := mmTxQuery.TxQueryMock.defaultExpectation.params
		mm_want_ptrs := mmTxQuery.TxQueryMock.defaultExpectation.paramPtrs

		mm_got := PostgresDBMockTxQueryParams{ctx, tx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTxQuery.t.Errorf("PostgresDBMock.TxQuery got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxQuery.TxQueryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmTxQuery.t.Errorf("PostgresDBMock.TxQuery got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxQuery.TxQueryMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmTxQuery.t.Errorf("PostgresDBMock.TxQuery got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxQuery.TxQueryMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmTxQuery.t.Errorf("PostgresDBMock.TxQuery got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTxQuery.TxQueryMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTxQuery.t.Errorf("PostgresDBMock.TxQuery got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTxQuery.TxQueryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTxQuery.TxQueryMock.defaultExpectation.results
		if mm_results == nil {
			mmTxQuery.t.Fatal("No results are set for the PostgresDBMock.TxQuery")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmTxQuery.funcTxQuery != nil {
		return mmTxQuery.funcTxQuery(ctx, tx, sql, args...)
	}
	mmTxQuery.t.Fatalf("Unexpected call to PostgresDBMock.TxQuery. %v %v %v %v", ctx, tx, sql, args)
	return
}

// TxQueryAfterCounter returns a count of finished PostgresDBMock.TxQuery invocations
func (mmTxQuery *PostgresDBMock) TxQueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxQuery.afterTxQueryCounter)
}

// TxQueryBeforeCounter returns a count of PostgresDBMock.TxQuery invocations
func (mmTxQuery *PostgresDBMock) TxQueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxQuery.beforeTxQueryCounter)
}

// Calls returns a list of arguments used in each call to PostgresDBMock.TxQuery.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTxQuery *mPostgresDBMockTxQuery) Calls() []*PostgresDBMockTxQueryParams {
	mmTxQuery.mutex.RLock()

	argCopy := make([]*PostgresDBMockTxQueryParams, len(mmTxQuery.callArgs))
	copy(argCopy, mmTxQuery.callArgs)

	mmTxQuery.mutex.RUnlock()

	return argCopy
}

// MinimockTxQueryDone returns true if the count of the TxQuery invocations corresponds
// the number of defined expectations
func (m *PostgresDBMock) MinimockTxQueryDone() bool {
	if m.TxQueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TxQueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TxQueryMock.invocationsDone()
}

// MinimockTxQueryInspect logs each unmet expectation
func (m *PostgresDBMock) MinimockTxQueryInspect() {
	for _, e := range m.TxQueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresDBMock.TxQuery at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTxQueryCounter := mm_atomic.LoadUint64(&m.afterTxQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TxQueryMock.defaultExpectation != nil && afterTxQueryCounter < 1 {
		if m.TxQueryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresDBMock.TxQuery at\n%s", m.TxQueryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresDBMock.TxQuery at\n%s with params: %#v", m.TxQueryMock.defaultExpectation.expectationOrigins.origin, *m.TxQueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxQuery != nil && afterTxQueryCounter < 1 {
		m.t.Errorf("Expected call to PostgresDBMock.TxQuery at\n%s", m.funcTxQueryOrigin)
	}

	if !m.TxQueryMock.invocationsDone() && afterTxQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresDBMock.TxQuery at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TxQueryMock.expectedInvocations), m.TxQueryMock.expectedInvocationsOrigin, afterTxQueryCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostgresDBMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExecInspect()

			m.MinimockExecQueryRowInspect()

			m.MinimockGetInspect()

			m.MinimockGetPoolInspect()

			m.MinimockQueryInspect()

			m.MinimockScanAllInspect()

			m.MinimockSelectInspect()

			m.MinimockTxBeginInspect()

			m.MinimockTxExecInspect()

			m.MinimockTxQueryInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostgresDBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostgresDBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExecDone() &&
		m.MinimockExecQueryRowDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetPoolDone() &&
		m.MinimockQueryDone() &&
		m.MinimockScanAllDone() &&
		m.MinimockSelectDone() &&
		m.MinimockTxBeginDone() &&
		m.MinimockTxExecDone() &&
		m.MinimockTxQueryDone()
}
